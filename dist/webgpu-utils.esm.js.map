{"version":3,"file":"webgpu-utils.esm.js","sources":["../src/struct.js","../src/utilities.js","../src/passes.js","../src/render_passes.js","../src/canvas.js","../src/core.js","../src/camera.js","../src/noise.js","../src/raycasting.js","../src/wgsl.js","../src/index.js"],"sourcesContent":["import { Buffer } from './core.js';\n\n/**\n * A WebGPU compatible data structure for defining structured buffers\n */\nexport class Struct {\n  /**\n   * Create a new Struct\n   * @param {string} name - The name of the struct in shader code\n   * @param {Array} [data=[]] - Initial data array of {name, type} objects\n   */\n  constructor(name, data = []) {\n    if (typeof name !== 'string' || name.trim() === '') {\n      throw new Error('Struct: Name must be a non-empty string');\n    }\n\n    this.name = name;\n    this.data = data;\n\n    // Add padding if needed to align to vec4 (16 bytes)\n    if (this.floatSize % 4 != 0) {\n      const fillerCount = 4 - (this.floatSize % 4);\n      for (let i = 0; i < fillerCount; i++) {\n        this.data.push({ name: `FILLER___${i}`, type: type_f32 });\n      }\n    }\n  }\n\n  /**\n   * Add a field to the struct\n   * @param {string} name - Field name\n   * @param {Object} type - Field type (one of the predefined types e.g. type_f32, type_vec2)\n   */\n  add(name, type) {\n    if (typeof name !== 'string' || name.trim() === '') {\n      throw new Error('Struct.add: Field name must be a non-empty string');\n    }\n    if (!type || typeof type !== 'object' || !('size' in type)) {\n      throw new Error('Struct.add: Invalid type provided');\n    }\n\n    this.data.push({ name, type });\n  }\n\n  /**\n   * Get the size of the struct in bytes\n   * @returns {number} Size in bytes\n   */\n  get byteSize() {\n    return this.data.reduce((acc, cur) => acc + cur.type.size, 0);\n  }\n\n  /**\n   * Get the size of the struct in float units (4 bytes each)\n   * @returns {number} Size in float units\n   */\n  get floatSize() {\n    return this.byteSize / 4;\n  }\n\n  /**\n   * Get the WGSL code representation of this struct\n   * @returns {string} WGSL struct declaration\n   */\n  get code() {\n    let str = 'struct ' + this.name + ' {\\n';\n    this.data.forEach(({ name, type }) => {\n      str += type.code(name) + ',\\n';\n    });\n    str = str.slice(0, -2); // Remove last comma and newline\n    return str + '\\n};';\n  }\n\n  /**\n   * Create a JavaScript object matching this struct with default values\n   * @returns {Object} Default object instance\n   */\n  object() {\n    const obj = {};\n    this.data.forEach(({ name, type }) => {\n      obj[name] = type.object();\n    });\n    return obj;\n  }\n\n  /**\n   * Convert JavaScript objects to Float32Array for GPU upload\n   * @param {Object|Array} vals - Object(s) to convert\n   * @returns {Float32Array} Packed Float32Array ready for GPU upload\n   * @throws {Error} If input is invalid\n   */\n  toFloat32Array(vals) {\n    if (!vals) {\n      throw new Error('Struct.toFloat32Array: Input values are required');\n    }\n\n    if (!(vals instanceof Array)) vals = [vals];\n    const arr = new Float32Array(this.floatSize * vals.length);\n    let offset = 0;\n\n    vals.forEach((val, i) => {\n      if (!val || typeof val !== 'object') {\n        throw new Error(`Struct.toFloat32Array: Invalid value at index ${i}`);\n      }\n\n      this.data.forEach(({ name, type }) => {\n        const value = val[name];\n        if (value === undefined) {\n          throw new Error(`Struct.toFloat32Array: Missing field ${name} at index ${i}`);\n        }\n\n        if (type instanceof Struct) {\n          arr.set(type.toFloat32Array(value), offset);\n        } else {\n          arr.set(type.toFloat32Array(value), offset);\n        }\n        offset += type.size / 4;\n      });\n    });\n\n    return arr;\n  }\n\n  /**\n   * Convert a Float32Array back to JavaScript objects\n   * @param {Float32Array} arr - Array to convert\n   * @returns {Array} Array of JavaScript objects\n   * @throws {Error} If the input is not a Float32Array\n   */\n  fromFloat32Array(arr) {\n    if (!(arr instanceof Float32Array)) {\n      throw new Error('Struct.fromFloat32Array: Input must be a Float32Array');\n    }\n\n    const vals = [];\n    let offset = 0;\n\n    while (offset < arr.length) {\n      const val = {};\n      this.data.forEach(({ name, type }) => {\n        if (offset + type.size / 4 > arr.length) {\n          throw new Error('Struct.fromFloat32Array: Array too short for struct layout');\n        }\n\n        if (type instanceof Struct) {\n          val[name] = type.fromFloat32Array(arr.slice(offset, offset + type.size / 4));\n        } else {\n          val[name] = type.fromFloat32Array(arr.slice(offset, offset + type.size / 4));\n        }\n        offset += type.size / 4;\n      });\n      vals.push(val);\n    }\n\n    return vals;\n  }\n\n  /**\n   * Create a WebGPU buffer from JavaScript objects\n   * @param {Array|Object} vals - Values to store in the buffer\n   * @param {string} name - Buffer name\n   * @returns {Buffer|Array<Buffer>} Buffer or array of buffers if data exceeds size limit\n   * @throws {Error} If input is invalid\n   */\n  createBuffer(name, vals) {\n    if (!vals) {\n      throw new Error('Struct.createBuffer: Values are required');\n    }\n\n    if (!Array.isArray(vals)) {\n      const newBuffer = new Buffer(name, this.toFloat32Array([vals]));\n      newBuffer.struct = this;\n      return newBuffer;\n    }\n\n    if (vals.length < 1) {\n      throw new Error('Struct.createBuffer: Empty values array');\n    }\n\n    if (vals.length < 65000) {\n      try {\n        const newBuffer = new Buffer(name, this.toFloat32Array(vals));\n        newBuffer.struct = this;\n        newBuffer.isArray = true\n        return newBuffer;\n      } catch (error) {\n        throw new Error(`Struct.createBuffer: Failed to create buffer: ${error.message}`);\n      }\n    }\n\n    // Split into multiple buffers if too large\n    const buffers = [];\n    for (let i = 0; i < vals.length; i += 65000) {\n      const nextData = vals.slice(i, i + 65000);\n      try {\n        const nextBuffer = new Buffer(name, this.toFloat32Array(nextData));\n        nextBuffer.count = nextData.length;\n        nextBuffer.struct = this;\n        nextBuffer.isArray = true;\n        buffers.push(nextBuffer);\n      } catch (error) {\n        throw new Error(`Struct.createBuffer: Failed to create buffer chunk ${i}: ${error.message}`);\n      }\n    }\n    return buffers;\n  }\n}\n\n/**\n * Float (f32) type definition for WGSL\n */\nexport const type_f32 = {\n  size: 4,\n  toFloat32Array: (val) => {\n    if (typeof val !== 'number') {\n      throw new Error('type_f32.toFloat32Array: Expected a number');\n    }\n    return new Float32Array([val]);\n  },\n  fromFloat32Array: (arr) => arr[0],\n  code: (name) => `${name}: f32`,\n  object: () => 0\n};\n\n/**\n * 2D vector (vec2<f32>) type definition for WGSL\n */\nexport const type_vec2 = {\n  size: 8,\n  toFloat32Array: (val) => {\n    if (!val || typeof val !== 'object' || !('x' in val) || !('y' in val)) {\n      throw new Error('type_vec2.toFloat32Array: Expected an object with x and y properties');\n    }\n    return new Float32Array([val.x, val.y]);\n  },\n  fromFloat32Array: (arr) => ({ x: arr[0], y: arr[1] }),\n  code: (name) => `${name}: vec2<f32>`,\n  object: () => ({ x: 0, y: 0 })\n};\n\n/**\n * 3D vector (vec3<f32>) type definition for WGSL\n */\nexport const type_vec3 = {\n  size: 12,\n  toFloat32Array: (val) => {\n    if (!val || typeof val !== 'object' || !('x' in val) || !('y' in val) || !('z' in val)) {\n      throw new Error('type_vec3.toFloat32Array: Expected an object with x, y, and z properties');\n    }\n    return new Float32Array([val.x, val.y, val.z]);\n  },\n  fromFloat32Array: (arr) => ({ x: arr[0], y: arr[1], z: arr[2] }),\n  code: (name) => `${name}: vec3<f32>`,\n  object: () => ({ x: 0, y: 0, z: 0 })\n};\n\n/**\n * 4D vector (vec4<f32>) type definition for WGSL\n */\nexport const type_vec4 = {\n  size: 16,\n  toFloat32Array: (val) => {\n    if (!val || typeof val !== 'object' || !('x' in val) || !('y' in val) || !('z' in val) || !('w' in val)) {\n      throw new Error('type_vec4.toFloat32Array: Expected an object with x, y, z, and w properties');\n    }\n    return new Float32Array([val.x, val.y, val.z, val.w]);\n  },\n  fromFloat32Array: (arr) => ({ x: arr[0], y: arr[1], z: arr[2], w: arr[3] }),\n  code: (name) => `${name}: vec4<f32>`,\n  object: () => ({ x: 0, y: 0, z: 0, w: 0 })\n};\n\n/**\n * RGBA color (vec4<f32>) type definition for WGSL\n * Used for color values with r,g,b,a components\n */\nexport const type_color = {\n  size: 16,\n  toFloat32Array: (val) => {\n    if (!val || typeof val !== 'object' || !('r' in val) || !('g' in val) || !('b' in val) || !('a' in val)) {\n      throw new Error('type_color.toFloat32Array: Expected an object with r, g, b, and a properties');\n    }\n    return new Float32Array([val.r, val.g, val.b, val.a]);\n  },\n  fromFloat32Array: (arr) => ({ r: arr[0], g: arr[1], b: arr[2], a: arr[3] }),\n  code: (name) => `${name}: vec4<f32>`,\n  object: () => ({ r: 0, g: 0, b: 0, a: 1 })\n};\n","import { Buffer } from './core.js';\nimport { Struct, type_f32, type_vec2 } from './struct.js';\nimport { canvas, height, width } from './canvas.js';\n\n/**\n * Generates a random number between two values\n * @param {number} [a=1] - Upper bound (if only one argument is provided) or range\n * @param {number} [b=0] - Lower bound\n * @returns {number} Random number between a and b\n */\nexport const random = (a = 1, b = 0) => Math.random() * (a - b) + b;\n\n/**\n * Selects a random element from an array\n * @param {Array} arr - The array to select from\n * @returns {*} Random element from the array\n * @throws {Error} If the array is empty or not an array\n */\nexport const choose = (arr) => {\n    if (!Array.isArray(arr)) {\n        throw new Error('choose: Expected an array as argument');\n    }\n    if (arr.length === 0) {\n        throw new Error('choose: Cannot select from an empty array');\n    }\n    return arr[Math.floor(random(arr.length))];\n};\n\n/**\n * Creates a promise that resolves after a specified time\n * @param {number} [ms=10] - Milliseconds to wait\n * @returns {Promise} Promise that resolves after the specified time\n */\nexport const timeout = async (ms = 10) => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Maps a value from one range to another\n * @param {number} val - The value to map\n * @param {number} inMin - Input range minimum\n * @param {number} inMax - Input range maximum\n * @param {number} outMin - Output range minimum\n * @param {number} outMax - Output range maximum\n * @returns {number} Mapped value\n */\nexport const map = (val, inMin, inMax, outMin, outMax) =>\n    outMin + (outMax - outMin) * (val - inMin) / (inMax - inMin);\n\n\n/**\n * Creates a mouse position buffer that updates on mouse movement\n * @returns {Buffer} Mouse position buffer with x, y coordinates and button state\n * @throws {Error} If canvas is not defined\n * @example\n * createMouseBuffer();\n * // This will create a buffer that updates with the mouse position and button state\n * @throws {Error} If canvas is not defined\n */\nexport let mouseBuffer = null;\nexport function createMouseBuffer() {\n    if (!canvas) {\n        throw new Error('createMouseBuffer: Canvas is not defined');\n    }\n    const mouseStruct = new Struct('mouseStruct', [\n        { name: 'pos', type: type_vec2 },\n        { name: 'button', type: type_f32 }\n    ])\n    mouseBuffer = mouseStruct.createBuffer('mouse', mouseStruct.object())\n    const mouseEvent = (e) => {\n        const rect = canvas.getBoundingClientRect()\n        const mouseIsDown = e.buttons == 1 ? 0 : 1\n        // mouseBuffer.update(mouseStruct.toFloat32Array([newMouseData]))\n        mouseBuffer.update(new Float32Array([\n            width * (e.clientX - rect.left) / rect.width,\n            height * (e.clientY - rect.top) / rect.height,\n            mouseIsDown\n        ]))\n    }\n    document.addEventListener('mousemove', mouseEvent)\n    document.addEventListener('mousedown', mouseEvent)\n    document.addEventListener('mouseup', mouseEvent)\n}\n\n\n/** * Creates a time buffer that updates with the current time in seconds\n * @returns {Buffer} Time buffer that updates with the current time\n * @example\n * createTimeBuffer();\n * // This will create a buffer that updates with the current time in seconds\n */\nexport let timeBuffer = null;\nexport function getTimeBuffer() {\n    if (!timeBuffer) {\n        throw new Error('getTimeBuffer: Time buffer has not been created yet');\n    }\n    return timeBuffer;\n}\nexport function createTimeBuffer() {\n    timeBuffer = new Buffer('time', new Float32Array([0]))\n    setInterval(() => {\n        timeBuffer.update(new Float32Array([performance.now() / 1000]))\n    }, 1000 / 60) // Update at 60 FPS\n    return timeBuffer\n}","// RenderPass and ComputePass classes extracted from render.js\n\nimport { device, ctx, canvasPresentationFormat, width, height } from './canvas.js';\nimport { renderTxtr, feedbackTxtr } from './render_passes.js';\nimport { mouseBuffer, timeBuffer } from './utilities.js';\n\nexport class RenderPass {\n    constructor(texture, code) {\n        if (!device) {\n            throw new Error('RenderPass: WebGPU device not initialized. Call initCanvas() first.');\n        }\n        if (!texture || typeof texture !== 'object') {\n            throw new Error('RenderPass: Invalid texture');\n        }\n        if (typeof code !== 'string' || code.trim() === '') {\n            throw new Error('RenderPass: Shader code must be a non-empty string');\n        }\n        try {\n            this.module = device.createShaderModule({ code });\n            this.pipeline = device.createRenderPipeline({\n                layout: 'auto',\n                vertex: { module: this.module, entryPoint: 'vs' },\n                fragment: { module: this.module, entryPoint: 'fs', targets: [{ format: canvasPresentationFormat }] },\n            });\n            this.sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });\n            this.bindGroup = device.createBindGroup({\n                layout: this.pipeline.getBindGroupLayout(0),\n                entries: [\n                    { binding: 0, resource: this.sampler },\n                    { binding: 1, resource: texture.resource },\n                ],\n            });\n            this.renderPassDescriptor = {\n                colorAttachments: [{ clearValue: [0, 0, 0, 1], loadOp: 'clear', storeOp: 'store' }],\n            };\n        } catch (error) {\n            throw new Error(`Failed to create RenderPass: ${error.message}`);\n        }\n    }\n    run(encoder) {\n        try {\n            this.renderPassDescriptor.colorAttachments[0].view = ctx.getCurrentTexture().createView();\n            const pass = encoder.beginRenderPass(this.renderPassDescriptor);\n            pass.setPipeline(this.pipeline);\n            pass.setBindGroup(0, this.bindGroup);\n            pass.draw(6);\n            pass.end();\n        } catch (error) {\n            throw new Error(`Failed to run RenderPass: ${error.message}`);\n        }\n    }\n}\n\n\nexport class ComputePass {\n    constructor(code, bindings, dispatchSize, entryPoint = 'main') {\n\n        // inject auto-bindings\n        const Auto_Bindings = [\n            { binding: mouseBuffer, regex: /\\bmouse(\\.(pos|button))?\\b/ },\n            { binding: timeBuffer, regex: /\\btime\\b/ },\n            { binding: renderTxtr, regex: /\\brenderTxtr\\b/, function: 'write' },\n            { binding: feedbackTxtr, regex: /\\bfeedbackTxtr\\b/, function: 'read' },\n        ];\n        Auto_Bindings.forEach(auto => {\n            if (code.match(auto.regex)) {\n                if (!bindings.some(b => b.name === auto.binding.name)) {\n                    const newBinding = auto.function ? auto.binding[auto.function]() : auto.binding;\n                    bindings.push(newBinding);\n                }\n            }\n        });\n\n\n        if (bindings.some(b => Array.isArray(b))) {\n            const multipleBuffer = bindings.find(b => Array.isArray(b))\n            const multipleBufferIndex = bindings.findIndex(b => Array.isArray(b))\n            return multipleBuffer.map((buffer, i) => {\n                const newBindings = bindings.slice()\n                newBindings[multipleBufferIndex] = buffer\n                return new ComputePass(code, newBindings, buffer.count, entryPoint)\n            })\n        }\n\n        let bindingsCode = ''\n        bindings.forEach((binding, i) => {\n            bindingsCode += binding.getBindingCode(i) + '\\n';\n        })\n        code = bindingsCode + code;\n\n        bindings.forEach(binding => {\n            if (binding.struct) code = binding.struct.code + '\\n' + code;\n        })\n\n        this.code = code\n\n        this.module = device.createShaderModule({ code });\n        this.pipeline = device.createComputePipeline({\n            layout: 'auto',\n            compute: { module: this.module, entryPoint },\n        });\n        this.bindGroup = device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(0),\n            entries: bindings.map((bind, i) => ({ binding: i, resource: bind.resource })),\n        });\n\n        this.dispatchSize = dispatchSize;\n        if (!Array.isArray(dispatchSize)) this.dispatchSize = [dispatchSize];\n    }\n\n    run(encoder) {\n        const pass = encoder.beginComputePass();\n        pass.setPipeline(this.pipeline);\n        pass.setBindGroup(0, this.bindGroup);\n        pass.dispatchWorkgroups(...this.dispatchSize);\n        pass.end();\n    }\n\n\n\n    /**\n     * Static methods\n     */\n    static texture(code, bindings){\n        return new ComputePass(code, bindings, [width, height]);\n    }\n    static compute(code, bindings, arr){\n        return new ComputePass(code, bindings, [arr.length]);\n    }\n}\n\n/**\n * Execute multiple render or compute passes\n * @param {Array} passes - Array of RenderPass or ComputePass objects (or arrays of passes)\n * @param {number} [repeats=1] - Number of times to repeat the passes\n * @throws {Error} If device is not initialized or passes are invalid\n */\nexport function runPasses(passes, repeats = 1) {\n    if (!device) {\n        throw new Error('runPasses: WebGPU device not initialized. Call initCanvas() first.');\n    }\n\n    if (!Array.isArray(passes))\n        passes = [passes];\n\n    try {\n        const commandEncoder = device.createCommandEncoder();\n        for (let i = 0; i < repeats; i++) {\n            for (const pass of passes) {\n                if (Array.isArray(pass)) {\n                    pass.forEach(p => {\n                        if (!p || typeof p.run !== 'function') {\n                            throw new Error('Invalid pass object in array');\n                        }\n                        p.run(commandEncoder);\n                    });\n                } else {\n                    if (!pass || typeof pass.run !== 'function') {\n                        throw new Error('Invalid pass object');\n                    }\n                    pass.run(commandEncoder);\n                }\n            }\n        }\n        device.queue.submit([commandEncoder.finish()]);\n    } catch (error) {\n        throw new Error(`Failed to run passes: ${error.message}`);\n    }\n}","/**\n * @file WebGPU render passes for common operations\n * Provides specialized render passes for common rendering tasks\n */\n\nimport { RenderPass, ComputePass, runPasses } from './passes.js';\nimport { Texture } from './core.js';\nimport { width, height } from './canvas.js';\n\n/**\n * Global rendering parameters\n * @type {Object}\n */\nconst renderParams = {\n    bgColor: [0, 0, 0]\n};\n\n/**\n * Texture array for render targets\n * @type {Array}\n */\nexport let renderTxtr, feedbackTxtr\nexport let renderPass, matchPass, clearPass;\n\n/**\n * Creates a standard render pass for displaying to screen\n * @async\n * @param {Object} [options] - Render pass options\n * @param {Array<number>} [options.bgColor] - Background color [r, g, b] (0-255)\n * @returns {Promise<RenderPass>} The configured render pass\n */\nexport async function createRenderPass(options = {}) {\n    if (options.bgColor) {\n        renderParams.bgColor = options.bgColor;\n    }\n\n    await createTextures();\n\n    createClearPass()\n\n    renderPass = new RenderPass(renderTxtr, basicRenderCode);\n    return renderPass;\n}\n\n/**\n * Creates textures for rendering\n * @async\n * @returns {Promise<void>}\n */\nexport async function createTextures() {\n    try {\n        renderTxtr = new Texture('renderTxtr', width, height);\n        feedbackTxtr = new Texture('feedbackTxtr', width, height);\n\n        const code = `\n        @compute @workgroup_size(1)\n        fn main(@builtin(global_invocation_id) id: vec3<u32>) {\n          let x: i32 = i32(id.x);\n          let y: i32 = i32(id.y);\n          let clr = vec4f(${renderParams.bgColor[0] / 255},${renderParams.bgColor[1] / 255},${renderParams.bgColor[2] / 255},1.0);\n          textureStore(renderTxtr, vec2<i32>(x, y), clr);\n          textureStore(feedbackTxtr, vec2<i32>(x, y), clr);\n        }`;\n\n        const pass1 = new ComputePass(code, [renderTxtr.write(), feedbackTxtr.write()], [width, height]);\n        runPasses([pass1]);\n    } catch (error) {\n        throw new Error(`Failed to create textures: ${error.message}`);\n    }\n}\n\n/**\n * Basic render code for fullscreen quad rendering\n * @type {string}\n */\nexport const basicRenderCode = `\n    struct OurVertexShaderOutput {\n        @builtin(position) position: vec4f,\n        @location(0) uv: vec2f,\n    };\n\n    @vertex fn vs(@builtin(vertex_index) vertexIndex: u32) -> OurVertexShaderOutput {\n        let pos = array(\n            vec2f(-1.0, -1.0), vec2f(1.0, -1.0),\n            vec2f(-1.0, 1.0), vec2f(-1.0, 1.0),\n            vec2f(1.0, -1.0), vec2f(1.0, 1.0),\n        );\n\n        var vsOutput: OurVertexShaderOutput;\n        let xy = pos[vertexIndex];\n        vsOutput.position = vec4f(xy, 0.0, 1.0);\n        vsOutput.uv = vec2f((xy.x + 1.0) / 2.0, 1.0-(xy.y + 1.0) / 2.0);\n        return vsOutput;\n    }\n\n    @group(0) @binding(0) var ourSampler: sampler;\n    @group(0) @binding(1) var ourTexture: texture_2d<f32>;\n\n    @fragment fn fs(fsInput: OurVertexShaderOutput) -> @location(0) vec4f {\n        return textureSample(ourTexture, ourSampler, fsInput.uv);\n    }\n    `;\n\n/**\n * Creates a pass that matches/copies one texture to another\n * @async\n * @returns {Promise<ComputePass>} The configured compute pass\n */\nexport async function createMatchPass() {\n    if (!renderTxtr || !feedbackTxtr) {\n        throw new Error('createMatchPass: Textures must be created first with createTextures()');\n    }\n\n    const code = `\n    @compute @workgroup_size(1)\n    fn main(@builtin(global_invocation_id) id: vec3<u32>) {\n      let x: i32 = i32(id.x);\n      let y: i32 = i32(id.y);\n      let clr = textureLoad(renderTxtr, vec2<i32>(x, y), 0);\n      textureStore(feedbackTxtr, vec2<i32>(x, y), vec4<f32>(clr.r, clr.g, clr.b, 1.0));\n    }`;\n\n    matchPass = new ComputePass(code, [renderTxtr.read(), feedbackTxtr.write()], [width, height]);\n    return matchPass;\n}\n\n/**\n * Creates a pass that clears all textures to the background color\n * @async\n * @returns {Promise<ComputePass>} The configured compute pass\n */\nexport async function createClearPass() {\n    if (!renderTxtr || !feedbackTxtr) {\n        throw new Error('createClearPass: Textures must be created first with createTextures()');\n    }\n\n    const code = `\n    @compute @workgroup_size(1)\n    fn main(@builtin(global_invocation_id) id: vec3<u32>) {\n      let x: i32 = i32(id.x);\n      let y: i32 = i32(id.y);\n\n      var clr = vec4<f32>(${renderParams.bgColor[0] / 255}, ${renderParams.bgColor[1] / 255}, ${renderParams.bgColor[2] / 255}, 1.0);\n\n      textureStore(renderTxtr, vec2<i32>(x, y), clr);\n      textureStore(feedbackTxtr, vec2<i32>(x, y), clr);\n    }`;\n\n    clearPass = new ComputePass(code, [renderTxtr.write(), feedbackTxtr.write()], [width, height]);\n    return clearPass;\n}\n\n/**\n * Set background color and update render parameters\n * @param {Array<number>} color - RGB color values [0-255]\n */\nexport function setBackgroundColor(color) {\n    if (!Array.isArray(color) || color.length < 3) {\n        throw new Error('setBackgroundColor: Expected an array of at least 3 RGB values [0-255]');\n    }\n\n    renderParams.bgColor = color.map(v => Math.max(0, Math.min(255, v)));\n}\n\nexport default {\n    renderParams,\n    createRenderPass,\n    createTextures,\n    basicRenderCode,\n    createMatchPass,\n    createClearPass,\n    setBackgroundColor\n};\n","/**\n * @file WebGPU canvas initialization and rendering utilities\n * Provides functions to initialize a WebGPU canvas, set up the rendering context,\n * and handle basic rendering operations.\n */\n\nimport { createMatchPass, createRenderPass } from \"./render_passes\";\nimport { createMouseBuffer, createTimeBuffer } from \"./utilities\";\n\nexport let width, height, device;\nexport let canvas, canvasPresentationFormat, ctx;\n\n/**\n * Initialize the WebGPU canvas and device\n * @param {Object} [options] - Canvas initialization options\n * @param {number} [options.width] - Canvas width (defaults to window width * 2)\n * @param {number} [options.height] - Canvas height (defaults to window height * 2)\n * @param {HTMLCanvasElement} [options.canvas] - Existing canvas to use (creates one if not provided)\n * @param {string} [options.containerId] - ID of the container to append the canvas to and size it to\n * @returns {Promise<{device: GPUDevice, canvas: HTMLCanvasElement, width: number, height: number}>}\n * @throws {Error} If WebGPU is not supported or initialization fails\n */\nexport async function initCanvas(options = {}) {\n    if (!navigator.gpu) {\n        throw new Error('WebGPU not supported in this browser.');\n    }\n\n    try {\n        const adapter = await navigator.gpu?.requestAdapter();\n        if (!adapter) {\n            throw new Error('Couldn\\'t request WebGPU adapter.');\n        }\n\n        device = await adapter.requestDevice();\n        if (!device) {\n            throw new Error('Couldn\\'t request WebGPU device.');\n        }\n\n        // Set up error handling for device\n        device.addEventListener('uncapturederror', (event) => {\n            console.error('WebGPU device error:', event.error);\n        });\n\n        // Get or create canvas\n        canvas = options.canvas || document.querySelector('canvas');\n        if (!canvas) {\n            canvas = document.createElement('canvas');\n        }\n\n        let container = null;\n        if (options.containerId) {\n            container = document.getElementById(options.containerId);\n            if (!container) {\n                throw new Error(`Container with ID '${options.containerId}' not found.`);\n            }\n            container.appendChild(canvas);\n            width = container.clientWidth;\n            height = container.clientHeight;\n            canvas.style.display = 'block';\n        } else {\n            if (!options.canvas) {\n                document.body.appendChild(canvas);\n            }\n            width = window.innerWidth;\n            height = window.innerHeight;\n        }\n\n        if (options.width) width = options.width;\n        if (options.height) height = options.height;\n\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n        width *= 2\n        height *= 2\n        canvas.width = width;\n        canvas.height = height;\n\n        // Configure WebGPU context\n        ctx = canvas.getContext('webgpu');\n        if (!ctx) {\n            throw new Error('Couldn\\'t get WebGPU context from canvas.');\n        }\n\n        canvasPresentationFormat = navigator.gpu.getPreferredCanvasFormat();\n        ctx.configure({\n            device,\n            format: canvasPresentationFormat,\n            alphaMode: 'premultiplied'\n        });\n\n        // Add keyboard shortcut for saving canvas\n        window.addEventListener('keydown', (e) => {\n            if (e.key === 's') {\n                const a = document.createElement('a');\n                a.href = canvas.toDataURL();\n                a.download = 'webgpu-image-' + new Date().toISOString().replace(/:/g, '-') + '.png';\n                a.click();\n            }\n        });\n\n        // In your WebGPU initialization (e.g. after device, ctx, canvasPresentationFormat are set):\n        // _setWebGPUContext(device, ctx, canvasPresentationFormat);\n\n        // Export reference variables to global scope for convenience\n        return { device, canvas, width, height };\n    } catch (error) {\n        throw new Error(`Failed to initialize canvas: ${error.message}`);\n    }\n}\n\n// Check if WebGPU is supported in the current browser\nexport function isWebGPUSupported() {\n    return typeof navigator !== 'undefined' && navigator && ('gpu' in navigator);\n}\n\n// Utility to create a promise that resolves when the DOM is loaded\nexport function domReady() {\n    return new Promise(resolve => {\n        if (document.readyState === 'complete' || document.readyState === 'interactive') {\n            resolve();\n        } else {\n            document.addEventListener('DOMContentLoaded', () => resolve());\n        }\n    });\n}\n\n// Initialize the library and canvas in one call\nexport async function init(options = {}) {\n    await domReady();\n    await initCanvas(options);\n    if (options.mouse) createMouseBuffer();\n    if (options.time) createTimeBuffer();\n    createRenderPass();\n    if (options.feedback) createMatchPass();\n}","/**\n * WebGPU Core Module\n * Provides basic WebGPU functionality including buffer and texture creation.\n * This module is designed to be used with the WebGPU API and requires a compatible browser.\n */\n\nimport { device } from './canvas.js';\n\n/**\n * Create WebGPU buffer\n * @class\n */\nexport class Buffer {\n    /**\n     * Create a WebGPU buffer\n     * @param {string} [name=''] - Name for the buffer\n     * @param {Float32Array|Array} data - Data to store in buffer\n     * @throws {Error} If device is not initialized or buffer creation fails\n     */\n    constructor(name, data) {\n        if (!device) {\n            throw new Error('Buffer: WebGPU device not initialized. Call initCanvas() first.');\n        }\n\n        try {\n            this.name = name;\n\n            // Convert array to Float32Array if needed\n            if (Array.isArray(data)) {\n                data = new Float32Array(data);\n            } else if (!(data instanceof Float32Array)) {\n                throw new Error('Buffer: Data must be an Array or Float32Array');\n            }\n\n            this.data = data;\n            this.size = data.byteLength;\n\n            // Create the GPU buffer\n            this.buffer = device.createBuffer({\n                label: this.name,\n                size: this.size,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n                mappedAtCreation: true\n            });\n\n            // Write data to the buffer\n            new Float32Array(this.buffer.getMappedRange()).set(data);\n            this.buffer.unmap();\n\n            // Create resource binding\n            this.resource = { buffer: this.buffer };\n        } catch (error) {\n            throw new Error(`Failed to create Buffer: ${error.message}`);\n        }\n    }\n\n    /**\n     * Update buffer data\n     * @param {Float32Array|Array} data - New data for the buffer\n     */\n    update(data) {\n        if (!data || (!Array.isArray(data) && !(data instanceof Float32Array))) {\n            throw new Error('Buffer.update: Data must be an Array or Float32Array');\n        }\n\n        try {\n            // Convert array to Float32Array if needed\n            if (Array.isArray(data)) {\n                data = new Float32Array(data);\n            }\n\n            // Update data\n            device.queue.writeBuffer(this.buffer, 0, data);\n            this.data = data;\n        } catch (error) {\n            throw new Error(`Failed to update Buffer: ${error.message}`);\n        }\n    }\n\n    /**\n     * Get binding code for this buffer\n     * @param {number} index - Binding index for the buffer\n     * @returns {string} WGSL binding code for the buffer\n     * @throws {Error} If buffer resource is not initialized\n     */\n    getBindingCode(index) {\n        if (!this.resource || !this.resource.buffer) {\n            throw new Error('Buffer.getBindingCode: Buffer resource not initialized');\n        }\n\n        let bufferType = 'f32';\n        if (this.struct) bufferType = this.struct.name;\n        else {\n            if (this.size == 4) bufferType = 'f32';\n            else if (this.size == 8) bufferType = 'vec2f';\n            else if (this.size == 12) bufferType = 'vec3f';\n            else if (this.size == 16) bufferType = 'vec4f';\n        }\n        if (this.isArray) bufferType = `array<${bufferType}>`;\n        return `@group(0) @binding(${index}) var<storage, read_write> ${this.name}: ${bufferType};`\n    }\n\n    async getData(){\n        // get the data from the buffer\n        const readBuffer = device.createBuffer({\n            size: this.size,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n\n        // Step 2: Create a command encoder and copy the buffer\n        const commandEncoder = device.createCommandEncoder();\n        commandEncoder.copyBufferToBuffer(\n            this.buffer, // source buffer\n            0,           // source offset\n            readBuffer,  // destination buffer\n            0,           // destination offset\n            this.size    // size\n        );\n\n        // Submit the commands\n        const commands = commandEncoder.finish();\n        device.queue.submit([commands]);\n\n        // Step 3: Map the read buffer and read the data\n        await readBuffer.mapAsync(GPUMapMode.READ);\n        const copyArrayBuffer = readBuffer.getMappedRange();\n\n        // Assuming the data is float32\n        const newdata = [...new Float32Array(copyArrayBuffer)]\n\n        // Don't forget to unmap the buffer\n        readBuffer.unmap();\n        return newdata\n    }\n}\n\n/**\n * WebGPU Texture wrapper\n * @class\n */\nexport class Texture {\n    /**\n     * Create a WebGPU texture\n     * @param {string} [name=''] - Name for the texture\n     * @param {number} [width=512] - Texture width\n     * @param {number} [height=512] - Texture height\n     * @param {GPUTextureFormat} [format='rgba8unorm'] - Texture format\n     * @throws {Error} If device is not initialized or texture creation fails\n     */\n    constructor(name = '', width = 512, height = 512, format = 'rgba8unorm') {\n        if (!device) {\n            throw new Error('Texture: WebGPU device not initialized. Call initCanvas() first.');\n        }\n\n        try {\n            this.name = name;\n            this.width = width;\n            this.height = height;\n            this.format = format;\n\n            // Create the texture\n            this.texture = device.createTexture({\n                label: this.name,\n                size: [width, height, 1],\n                format,\n                usage: GPUTextureUsage.COPY_DST |\n                    GPUTextureUsage.STORAGE_BINDING |\n                    GPUTextureUsage.TEXTURE_BINDING\n            });\n\n            // Create texture view\n            this.view = this.texture.createView();\n            this.resource = this.view;\n        } catch (error) {\n            throw new Error(`Failed to create Texture: ${error.message}`);\n        }\n    }\n\n    /**\n     * Get binding for this texture in read mode\n     * @returns {GPUTextureView} Texture view for binding\n     */\n    read() {\n        return new TextureBindingHelper(this, 'read');\n    }\n\n    /**\n     * Get binding for this texture in write mode\n     * @returns {GPUTextureView} Texture view for binding\n     */\n    write() {\n        return new TextureBindingHelper(this, 'write');\n    }\n}\nfunction TextureBindingHelper(texture, readOrWrite = 'read') {\n    this.texture = texture;\n    this.readOrWrite = readOrWrite;\n    this.resource = texture.resource\n    this.name = texture.name;\n\n    this.getBindingCode = (bindingIndex) => {\n        if (this.readOrWrite === 'read' && this.texture.format == 'rgba8unorm') {\n            return `@group(0) @binding(${bindingIndex}) var ${this.texture.name}: texture_2d<f32>;`\n        }\n        return `@group(0) @binding(${bindingIndex}) var ${this.texture.name}: texture_storage_2d<${this.texture.format}, ${this.readOrWrite}>;`\n    }\n}\n","/**\n * @file WebGPU camera utilities for WGSL shaders\n * Provides camera functions and perspective calculations for 3D rendering\n */\n\nimport { width, height } from './canvas.js';\n\n/**\n * Generates camera-related WGSL code\n * @param {Object} [options] - Camera configuration options\n * @param {number} [options.cameraDistance=250.0] - Base distance of camera from origin\n * @param {number} [options.rotationSpeed=0.01] - Camera rotation speed\n * @param {number} [options.fieldOfView=90.0] - Camera field of view in degrees\n * @param {number} [options.nearPlane=1.0] - Near clipping plane distance\n * @param {number} [options.farPlane=1000.0] - Far clipping plane distance\n * @param {number} [options.cameraY=-100.0] - Camera Y position\n * @returns {string} WGSL camera code\n */\nexport function getCamStuff(options = {}) {\n    const {\n        cameraDistance = 250.0,\n        rotationSpeed = 0.01,\n        fieldOfView = 90.0,\n        nearPlane = 1.0,\n        farPlane = 1000.0,\n        cameraY = -100.0\n    } = options;\n\n    return `\n    // Camera configuration constants\n    const BASE_CAMERA_DISTANCE = ${cameraDistance};\n    const ROTATION_SPEED = ${rotationSpeed};            // Adjust this to change rotation speed\n    const FIELD_OF_VIEW = ${fieldOfView};\n    const ASPECT_RATIO = ${width / height};\n    const NEAR_PLANE = ${nearPlane};\n    const FAR_PLANE = ${farPlane};\n    const CAMERA_UP = vec3 < f32 > (0.0, 1.0, 0.0);\n\n    // Orthographic parameters\n    const ORTHO_SIZE = 5.0;               // Size of the orthographic view (height)\n    const ORTHO_WIDTH = ORTHO_SIZE * ASPECT_RATIO;\n    const ORTHO_HEIGHT = ORTHO_SIZE;\n\n    fn calculateCameraPosition() -> vec3 < f32 > {\n        let angle = globalData[0].frame * ROTATION_SPEED;\n        return vec3 < f32 > (\n            cos(angle) * BASE_CAMERA_DISTANCE,\n            ${cameraY},\n            sin(angle) * BASE_CAMERA_DISTANCE\n        );\n    }\n\n    fn lookAt(eye: vec3 < f32 >, targetDir: vec3 < f32 >, up: vec3 < f32 >) -> mat4x4 < f32 > {\n        let f = normalize(targetDir - eye);\n        let s = normalize(cross(f, up));\n        let u = cross(s, f);\n\n        return mat4x4 < f32 > (\n            vec4 < f32 > (s.x, u.x, -f.x, 0.0),\n            vec4 < f32 > (s.y, u.y, -f.y, 0.0),\n            vec4 < f32 > (s.z, u.z, -f.z, 0.0),\n            vec4 < f32 > (-dot(s, eye), -dot(u, eye), dot(f, eye), 1.0)\n        );\n    }\n\n    fn perspectiveMatrix() -> mat4x4 < f32 > {\n        let fovRad = radians(FIELD_OF_VIEW);\n        let f = 1.0 / tan(fovRad / 2.0);\n\n        return mat4x4 < f32 > (\n            vec4 < f32 > (f / ASPECT_RATIO, 0.0, 0.0, 0.0),\n            vec4 < f32 > (0.0, f, 0.0, 0.0),\n            vec4 < f32 > (0.0, 0.0, (FAR_PLANE + NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), -1.0),\n            vec4 < f32 > (0.0, 0.0, (2.0 * FAR_PLANE * NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), 0.0)\n        );\n    }\n\n    fn worldToScreenPerspective(worldPos: vec3 < f32 >) -> vec2 < f32 > {\n        let cameraPos = calculateCameraPosition();\n        let viewMatrix = lookAt(cameraPos, vec3 < f32 > (0.0, 0.0, 0.0), CAMERA_UP);\n        let projMatrix = perspectiveMatrix();\n        let viewProj = projMatrix * viewMatrix;\n\n        // Transform to clip space\n        let clipPos = viewProj * vec4 < f32 > (worldPos, 1.0);\n\n        // Perspective division\n        let ndcPos = clipPos.xyz / clipPos.w;\n\n        // Convert to screen coordinates [0,1]\n        return vec2 < f32 > (\n            (ndcPos.x + 1.0) * 0.5,\n            (ndcPos.y + 1.0) * 0.5\n        );\n    }\n    `;\n}\n\n/**\n * Creates a static camera at a specific position\n * @param {Object} position - Camera position\n * @param {number} position.x - X coordinate\n * @param {number} position.y - Y coordinate\n * @param {number} position.z - Z coordinate\n * @param {Object} [target] - Camera target position (default: origin)\n * @param {number} [target.x=0] - Target X coordinate\n * @param {number} [target.y=0] - Target Y coordinate\n * @param {number} [target.z=0] - Target Z coordinate\n * @returns {string} WGSL code for a static camera\n */\nexport function createStaticCamera(position, target = { x: 0, y: 0, z: 0 }) {\n    if (!position || typeof position !== 'object' || \n        typeof position.x !== 'number' || \n        typeof position.y !== 'number' || \n        typeof position.z !== 'number') {\n        throw new Error('createStaticCamera: Valid position object with x, y, z coordinates is required');\n    }\n\n    return `\n    // Static camera configuration constants\n    const FIELD_OF_VIEW = 90.0;\n    const ASPECT_RATIO = ${width / height};\n    const NEAR_PLANE = 1.0;\n    const FAR_PLANE = 1000.0;\n    const CAMERA_UP = vec3 < f32 > (0.0, 1.0, 0.0);\n    \n    const CAMERA_POSITION = vec3<f32>(${position.x}, ${position.y}, ${position.z});\n    const CAMERA_TARGET = vec3<f32>(${target.x}, ${target.y}, ${target.z});\n\n    fn calculateCameraPosition() -> vec3 < f32 > {\n        return CAMERA_POSITION;\n    }\n\n    fn lookAt(eye: vec3 < f32 >, targetDir: vec3 < f32 >, up: vec3 < f32 >) -> mat4x4 < f32 > {\n        let f = normalize(targetDir - eye);\n        let s = normalize(cross(f, up));\n        let u = cross(s, f);\n\n        return mat4x4 < f32 > (\n            vec4 < f32 > (s.x, u.x, -f.x, 0.0),\n            vec4 < f32 > (s.y, u.y, -f.y, 0.0),\n            vec4 < f32 > (s.z, u.z, -f.z, 0.0),\n            vec4 < f32 > (-dot(s, eye), -dot(u, eye), dot(f, eye), 1.0)\n        );\n    }\n\n    fn perspectiveMatrix() -> mat4x4 < f32 > {\n        let fovRad = radians(FIELD_OF_VIEW);\n        let f = 1.0 / tan(fovRad / 2.0);\n\n        return mat4x4 < f32 > (\n            vec4 < f32 > (f / ASPECT_RATIO, 0.0, 0.0, 0.0),\n            vec4 < f32 > (0.0, f, 0.0, 0.0),\n            vec4 < f32 > (0.0, 0.0, (FAR_PLANE + NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), -1.0),\n            vec4 < f32 > (0.0, 0.0, (2.0 * FAR_PLANE * NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), 0.0)\n        );\n    }\n\n    fn worldToScreenPerspective(worldPos: vec3 < f32 >) -> vec2 < f32 > {\n        let cameraPos = calculateCameraPosition();\n        let viewMatrix = lookAt(cameraPos, CAMERA_TARGET, CAMERA_UP);\n        let projMatrix = perspectiveMatrix();\n        let viewProj = projMatrix * viewMatrix;\n\n        // Transform to clip space\n        let clipPos = viewProj * vec4 < f32 > (worldPos, 1.0);\n\n        // Perspective division\n        let ndcPos = clipPos.xyz / clipPos.w;\n\n        // Convert to screen coordinates [0,1]\n        return vec2 < f32 > (\n            (ndcPos.x + 1.0) * 0.5,\n            (ndcPos.y + 1.0) * 0.5\n        );\n    }\n    `;\n}\n\n/**\n * Creates a first-person camera controller WGSL code\n * @param {Object} [options] - First-person camera options\n * @param {Object} [options.initialPosition={ x: 0, y: 2, z: 5 }] - Starting position\n * @param {Object} [options.initialLookAt={ x: 0, y: 0, z: 0 }] - Initial look target\n * @param {number} [options.moveSpeed=0.1] - Camera movement speed\n * @param {number} [options.sensitivity=0.003] - Mouse look sensitivity\n * @returns {string} WGSL first-person camera code\n */\nexport function createFirstPersonCamera(options = {}) {\n    const {\n        initialPosition = { x: 0, y: 2, z: 5 },\n        initialLookAt = { x: 0, y: 0, z: 0 },\n        moveSpeed = 0.1,\n        sensitivity = 0.003\n    } = options;\n    \n    return `\n    // First-person camera constants\n    const CAMERA_MOVE_SPEED = ${moveSpeed};\n    const MOUSE_SENSITIVITY = ${sensitivity};\n    const FIELD_OF_VIEW = 70.0;\n    const ASPECT_RATIO = ${width / height};\n    const NEAR_PLANE = 0.1;\n    const FAR_PLANE = 1000.0;\n    const CAMERA_UP = vec3<f32>(0.0, 1.0, 0.0);\n    \n    // Camera state (should be fed from uniform buffer in real implementation)\n    var<private> camera_position = vec3<f32>(${initialPosition.x}, ${initialPosition.y}, ${initialPosition.z});\n    var<private> camera_front = normalize(vec3<f32>(${initialLookAt.x - initialPosition.x}, \n                                                   ${initialLookAt.y - initialPosition.y},\n                                                   ${initialLookAt.z - initialPosition.z}));\n    var<private> camera_right = normalize(cross(camera_front, CAMERA_UP));\n    var<private> camera_up = normalize(cross(camera_right, camera_front));\n    var<private> yaw = -90.0; // Default is looking along negative z\n    var<private> pitch = 0.0;\n    \n    fn updateCameraVectors() {\n        let direction = vec3<f32>(\n            cos(radians(yaw)) * cos(radians(pitch)),\n            sin(radians(pitch)),\n            sin(radians(yaw)) * cos(radians(pitch))\n        );\n        \n        camera_front = normalize(direction);\n        camera_right = normalize(cross(camera_front, CAMERA_UP));\n        camera_up = normalize(cross(camera_right, camera_front));\n    }\n    \n    fn moveCamera(direction: i32) {\n        switch direction {\n            case 0: { // Forward\n                camera_position += CAMERA_MOVE_SPEED * camera_front;\n            }\n            case 1: { // Backward\n                camera_position -= CAMERA_MOVE_SPEED * camera_front;\n            }\n            case 2: { // Left\n                camera_position -= CAMERA_MOVE_SPEED * camera_right;\n            }\n            case 3: { // Right\n                camera_position += CAMERA_MOVE_SPEED * camera_right;\n            }\n            case 4: { // Up\n                camera_position += CAMERA_MOVE_SPEED * CAMERA_UP;\n            }\n            case 5: { // Down\n                camera_position -= CAMERA_MOVE_SPEED * CAMERA_UP;\n            }\n            default: {}\n        }\n    }\n    \n    fn rotateCamera(xoffset: f32, yoffset: f32) {\n        yaw += xoffset * MOUSE_SENSITIVITY;\n        pitch += yoffset * MOUSE_SENSITIVITY;\n        \n        // Constrain pitch\n        pitch = clamp(pitch, -89.0, 89.0);\n        \n        updateCameraVectors();\n    }\n    \n    fn getViewMatrix() -> mat4x4<f32> {\n        let target = camera_position + camera_front;\n        return lookAt(camera_position, target, camera_up);\n    }\n    \n    fn lookAt(eye: vec3<f32>, target: vec3<f32>, up: vec3<f32>) -> mat4x4<f32> {\n        let f = normalize(target - eye);\n        let r = normalize(cross(f, up));\n        let u = cross(r, f);\n        \n        return mat4x4<f32>(\n            vec4<f32>(r.x, u.x, -f.x, 0.0),\n            vec4<f32>(r.y, u.y, -f.y, 0.0),\n            vec4<f32>(r.z, u.z, -f.z, 0.0),\n            vec4<f32>(-dot(r, eye), -dot(u, eye), dot(f, eye), 1.0)\n        );\n    }\n    \n    fn perspectiveMatrix() -> mat4x4<f32> {\n        let fovRad = radians(FIELD_OF_VIEW);\n        let f = 1.0 / tan(fovRad / 2.0);\n        \n        return mat4x4<f32>(\n            vec4<f32>(f / ASPECT_RATIO, 0.0, 0.0, 0.0),\n            vec4<f32>(0.0, f, 0.0, 0.0),\n            vec4<f32>(0.0, 0.0, (FAR_PLANE + NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), -1.0),\n            vec4<f32>(0.0, 0.0, (2.0 * FAR_PLANE * NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), 0.0)\n        );\n    }\n    \n    fn worldToScreenPerspective(worldPos: vec3<f32>) -> vec2<f32> {\n        let viewMatrix = getViewMatrix();\n        let projMatrix = perspectiveMatrix();\n        let viewProj = projMatrix * viewMatrix;\n        \n        // Transform to clip space\n        let clipPos = viewProj * vec4<f32>(worldPos, 1.0);\n        \n        // Perspective division\n        let ndcPos = clipPos.xyz / clipPos.w;\n        \n        // Convert to screen coordinates [0,1]\n        return vec2<f32>(\n            (ndcPos.x + 1.0) * 0.5,\n            (ndcPos.y + 1.0) * 0.5\n        );\n    }\n    `;\n}\n\nexport default {\n    getCamStuff,\n    createStaticCamera,\n    createFirstPersonCamera\n};\n","/**\n * @file WebGPU shader noise utilities\n * Provides noise functions for WGSL shaders\n */\n\nimport { Buffer } from './core.js';\n\nlet noiseBuffer = null;\n\n/**\n * Get WGSL code for noise functions\n * @returns {string} WGSL noise functions code\n */\nexport function getNoiseCode() {\n    // Create a noise offset buffer if it doesn't exist\n    if (!noiseBuffer) {\n        noiseBuffer = new Buffer([Math.random() * 1000, Math.random() * 1000, Math.random() * 1000], 'noiseOffset');\n    }\n\n    // Combine noise function implementations\n    return `\n    ${wgslNoise}\n    ${wgslNoise2}\n    `;\n}\n\n/**\n * Simple 1D noise function for WGSL\n * @type {string}\n */\nexport const wgslNoise = `\nfn rand(n: f32) -> f32 { return fract(sin(438.347 * n / 10000)); }\nfn noise(p: f32) -> f32 {\n  let pVal = p+noiseOffset.x;\n  let fl = floor(pVal);\n  let fc = fract(pVal);\n  return mix(rand(fl), rand(fl + 1.), fc);\n}\n`;\n\n/**\n * 2D simplex noise implementation for WGSL\n * @type {string}\n */\nexport const wgslNoise2 = \n`fn mod289(x: vec2<f32>) -> vec2<f32> {return x - floor(x * (1. / 289.)) * 289.;}\nfn mod289_3(x: vec3<f32>) -> vec3<f32> {return x - floor(x * (1. / 289.)) * 289.;}\nfn permute3(x: vec3<f32>) -> vec3<f32> {return mod289_3(((x * 34.) + 1.) * x);}\nfn noise2(v: vec2<f32>) -> f32 {\n  let v2 = v * .4 + noiseOffset.xy;\n  let C = vec4(\n      0.211324865405187, // (3.0-sqrt(3.0))/6.0\n      0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n      -0.577350269189626, // -1.0 + 2.0 * C.x\n      0.024390243902439 // 1.0 / 41.0\n  );\n  var i = floor(v2 + dot(v2, C.yy));\n  let x0 = v2 - i + dot(i, C.xx);\n  var i1 = select(vec2(0., 1.), vec2(1., 0.), x0.x > x0.y);\n  var x12 = x0.xyxy + C.xxzz;\n  x12.x = x12.x - i1.x;\n  x12.y = x12.y - i1.y;\n  i = mod289(i); // Avoid truncation effects in permutation\n  var p = permute3(permute3(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.));\n  var m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3(0.));\n  m *= m;\n  m *= m;\n  let x = 2. * fract(p * C.www) - 1.;\n  let h = abs(x) - 0.5;\n  let ox = floor(x + 0.5);\n  let a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  let g = vec3(a0.x * x0.x + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw);\n  return 130. * dot(m, g);\n}`;\n\n/**\n * 3D simplex noise implementation for WGSL\n * @type {string}\n */\nexport const wgslNoise3 = `\nfn mod289_f(x: f32) -> f32 { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfn mod289_vec3(x: vec3<f32>) -> vec3<f32> { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfn mod289_vec4(x: vec4<f32>) -> vec4<f32> { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfn permute_vec4(x: vec4<f32>) -> vec4<f32> { return mod289_vec4(((x * 34.0) + 1.0) * x); }\nfn taylorInvSqrt_f(r: f32) -> f32 { return 1.79284291400159 - 0.85373472095314 * r; }\nfn taylorInvSqrt_vec4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfn noise3(v: vec3<f32>) -> f32 {\n  let C = vec4<f32>(\n    0.1381966, // 1/6\n    0.2763932, // 1/3\n    0.5,\n    -0.5\n  );\n  \n  // First corner\n  var i = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n  \n  // Other corners\n  let g = step(x0.yzx, x0.xyz);\n  let l = 1.0 - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n  \n  let x1 = x0 - i1 + C.xxx;\n  let x2 = x0 - i2 + C.yyy;\n  let x3 = x0 - 0.5;\n  \n  // Permutations\n  i = mod289_vec3(i); // Avoid truncation effects in permutation\n  let p = permute_vec4(permute_vec4(permute_vec4(\n    i.z + vec4<f32>(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4<f32>(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4<f32>(0.0, i1.x, i2.x, 1.0));\n    \n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  let j = p - 49.0 * floor(p * (1.0 / 49.0));  // mod(p,7*7)\n  \n  let x_ = floor(j * (1.0 / 7.0));\n  let y_ = floor(j - 7.0 * x_);  // mod(j,N)\n  \n  let x = x_ * (2.0 / 7.0) + 0.5 / 7.0 - 1.0;\n  let y = y_ * (2.0 / 7.0) + 0.5 / 7.0 - 1.0;\n  \n  let h = 1.0 - abs(x) - abs(y);\n  \n  let b0 = vec4<f32>(x.xy, y.xy);\n  let b1 = vec4<f32>(x.zw, y.zw);\n  \n  let s0 = floor(b0) * 2.0 + 1.0;\n  let s1 = floor(b1) * 2.0 + 1.0;\n  let sh = -step(h, vec4<f32>(0.0));\n  \n  let a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  let a1 = b1.xzyw + s1.xzyw * sh.zzww;\n  \n  var p0 = vec3<f32>(a0.xy, h.x);\n  var p1 = vec3<f32>(a0.zw, h.y);\n  var p2 = vec3<f32>(a1.xy, h.z);\n  var p3 = vec3<f32>(a1.zw, h.w);\n  \n  // Normalise gradients\n  let norm = taylorInvSqrt_vec4(vec4<f32>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  \n  // Mix final noise value\n  var m = max(0.6 - vec4<f32>(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), vec4<f32>(0.0));\n  m = m * m;\n  return 42.0 * dot(m * m, vec4<f32>(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n`;\n\n/**\n * FBM (Fractal Brownian Motion) noise for WGSL\n * @type {string}\n */\nexport const wgslFBM = `\nfn fbm(p: vec2<f32>, octaves: i32) -> f32 {\n    var value = 0.0;\n    var amplitude = 0.5;\n    var frequency = 1.0;\n    var p2 = p + noiseOffset.xy * 10.0;\n    \n    for (var i = 0; i < octaves; i = i + 1) {\n        value += amplitude * noise2(p2 * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    \n    return value;\n}\n`;\n\n/**\n * WGSL function for voronoi noise\n * @type {string}\n */\nexport const wgslVoronoi = `\nfn voronoi(uv: vec2<f32>, scale: f32, seed: f32) -> f32 {\n    let s = scale;\n    let iuv = floor(uv * s);\n    let fuv = fract(uv * s);\n    var min_dist = 1.0;\n    \n    for (var y: i32 = -1; y <= 1; y = y + 1) {\n        for (var x: i32 = -1; x <= 1; x = x + 1) {\n            let neighbor = vec2<f32>(f32(x), f32(y));\n            let point = 0.5 + 0.5 * sin(seed + 6.2831 * rand(rand(iuv.x + neighbor.x + seed) + iuv.y + neighbor.y));\n            let diff = neighbor + point - fuv;\n            let dist = length(diff);\n            min_dist = min(min_dist, dist);\n        }\n    }\n    \n    return min_dist;\n}\n`;\n\nexport default { \n    getNoiseCode, \n    wgslNoise, \n    wgslNoise2, \n    wgslNoise3, \n    wgslFBM, \n    wgslVoronoi,\n    noiseBuffer \n};\n","/**\n * @file WebGPU ray casting utilities for WGSL shaders\n * Provides helper functions for ray-based rendering techniques\n */\n\n/**\n * WGSL code for 2D vector rotation\n * @type {string}\n */\nexport const wgsl_rotate = `fn rotate(v: vec2<f32>, a: f32) -> vec2<f32> {\n    let s = sin(a);\n    let c = cos(a);\n    return vec2<f32>(c * v.x - s * v.y, s * v.x + c * v.y);\n    }`;\n\n/**\n * WGSL code for rotating a vector around the Y axis\n * @type {string}\n */\nexport const wgsl_rotate_y = `fn rotate_y(vec: vec3<f32>, angle: f32) -> vec3<f32> {\n      let cos_theta = cos(angle);\n      let sin_theta = sin(angle);\n      return vec3<f32>(\n          vec.x * cos_theta + vec.z * sin_theta,\n          vec.y,\n          -vec.x * sin_theta + vec.z * cos_theta\n      );\n  }`;\n\n/**\n * WGSL struct definitions for ray casting\n * @type {string}\n */\nexport const wgsl_rayStruct = `\n  struct hit {\n    dist: f32,\n    index: i32,\n  };\n\n  struct Ray {\n    ro: vec3<f32>,\n    rd: vec3<f32>,\n  };`;\n\n/**\n * Default camera code for ray generation\n * @type {string}\n */\nexport let cameraCode = `\n  let theta = 0.0;\n  let camPos = vec3<f32>(0.0, 0.0, 1000.0);\n`;\n\n/**\n * Creates a WGSL function for ray generation\n * @param {Object} [options] - Options for ray generation\n * @param {string} [options.customCameraCode] - Custom camera setup code\n * @param {number} [options.width] - Canvas width\n * @param {number} [options.height] - Canvas height\n * @returns {string} WGSL function for ray generation\n */\nexport function createGetRayFunction(options = {}) {\n    const customCameraCode = options.customCameraCode || cameraCode;\n    const width = options.width || globalThis.width || 1000;\n    const height = options.height || globalThis.height || 1000;\n\n    return `\nfn getRay(x: i32, y: i32) -> Ray {\n    ${customCameraCode}\n    camPos = rotate_y(camPos, theta);\n    let lookAt = vec3<f32>(0.0, 0.0, 0.0);\n    let forward = normalize(lookAt - camPos);\n\n    // Calculate right vector (perpendicular to forward and world up)\n    let worldUp = vec3<f32>(0.0, 1.0, 0.0);\n    let right = normalize(cross(forward, worldUp));\n\n    // Calculate camera's up vector\n    let up = normalize(cross(right, forward));\n\n    // Screen coordinates relative to center\n    let screenX = f32(x) / 2 - ${width / 4};\n    let screenY = f32(y) / 2 - ${height / 4};\n\n    // Scale factors to control orthographic view size\n    let orthoScale = 1.0; // Adjust as needed\n\n    // For orthographic, we offset the ray origin in the plane perpendicular to viewing direction\n    let ro = camPos + (right * screenX * orthoScale) + (up * screenY * orthoScale);\n\n    // All rays have the same direction (parallel)\n    let rd = forward;\n\n    return Ray(ro, rd);\n  }\n`;\n}\n\n/**\n * Sets custom camera code for ray generation\n * @param {string} code - WGSL camera initialization code\n */\nexport function setCameraCode(code) {\n    if (typeof code !== 'string') {\n        throw new Error('setCameraCode: Camera code must be a string');\n    }\n    cameraCode = code;\n}\n\n/**\n * WGSL code for ray-sphere intersection tests\n * @type {string}\n */\nexport const wgsl_rayToSphere = `\nfn rayToSphere(ro: vec3<f32>, rd: vec3<f32>, sph: sphere) -> f32 {\n    let oc = ro - sph.pos;\n    // Since rd is typically normalized, a = dot(rd,rd) = 1.0\n    \n    let b = dot(oc, rd);\n    let c = dot(oc, oc) - sph.r * sph.r;\n    let discriminant = b * b - c;\n    \n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n\n    let t1 = -b - sqrt(discriminant);\n    let t2 = -b + sqrt(discriminant);\n\n    if (t1 > 0.0) {\n      return t1;\n    }\n    if (t2 > 0.0) {\n      return t2;\n    } else {\n      return -1.0;\n    }\n}\nfn isInSphere(pos: vec3<f32>, sph: sphere) -> bool {\n  return length(pos - sph.pos) <= sph.r;\n}\n`;\n\n/**\n * WGSL code for ray-plane intersection tests\n * @type {string}\n */\nexport const wgsl_rayToPlane = `\nstruct Plane {\n  normal: vec3<f32>,\n  distance: f32,\n};\n\nfn rayToPlane(ro: vec3<f32>, rd: vec3<f32>, plane: Plane) -> f32 {\n  let denom = dot(plane.normal, rd);\n  \n  // Check if ray is parallel to the plane\n  if (abs(denom) < 0.0001) {\n    return -1.0;\n  }\n  \n  let t = -(dot(ro, plane.normal) + plane.distance) / denom;\n  \n  // Only return positive intersection distance (in front of the ray)\n  if (t < 0.0) {\n    return -1.0;\n  }\n  \n  return t;\n}\n`;\n\n/**\n * WGSL code for ray-box intersection tests\n * @type {string}\n */\nexport const wgsl_rayToBox = `\nstruct Box {\n  min: vec3<f32>,\n  max: vec3<f32>,\n};\n\nfn rayToBox(ro: vec3<f32>, rd: vec3<f32>, box: Box) -> f32 {\n  let tMin = (box.min - ro) / rd;\n  let tMax = (box.max - ro) / rd;\n  \n  let t1 = min(tMin, tMax);\n  let t2 = max(tMin, tMax);\n  \n  let tNear = max(max(t1.x, t1.y), t1.z);\n  let tFar = min(min(t2.x, t2.y), t2.z);\n  \n  // Box is behind the ray or ray misses box\n  if (tNear > tFar || tFar < 0.0) {\n    return -1.0;\n  }\n  \n  // Return nearest positive hit\n  return tNear > 0.0 ? tNear : tFar;\n}\n\nfn isInBox(pos: vec3<f32>, box: Box) -> bool {\n  return all(pos >= box.min) && all(pos <= box.max);\n}\n`;\n\n/**\n * WGSL material definition for use with ray tracing\n * @type {string}\n */\nexport const wgsl_material = `\nstruct Material {\n  albedo: vec3<f32>,\n  roughness: f32,\n  metallic: f32,\n  emission: vec3<f32>,\n  ior: f32,\n};\n\nfn defaultMaterial() -> Material {\n  return Material(\n    vec3<f32>(0.8, 0.8, 0.8), // albedo (diffuse color)\n    0.5,                       // roughness\n    0.0,                       // metallic\n    vec3<f32>(0.0, 0.0, 0.0), // emission\n    1.45                       // index of refraction\n  );\n}\n`;\n\n/**\n * WGSL code for calculating surface normals\n * @type {string}\n */\nexport const wgsl_normals = `\nfn sphereNormal(hitPos: vec3<f32>, sphere: sphere) -> vec3<f32> {\n  return normalize(hitPos - sphere.pos);\n}\n\nfn planeNormal(plane: Plane) -> vec3<f32> {\n  return plane.normal;\n}\n\nfn boxNormal(hitPos: vec3<f32>, box: Box) -> vec3<f32> {\n  // Find the face that was hit by checking which component is closest to the respective face\n  let center = (box.min + box.max) * 0.5;\n  let d = hitPos - center;\n  let s = (box.max - box.min) * 0.5;\n  \n  let bias = 0.0001; // Small bias to avoid precision errors\n  let nx = d.x / (s.x + bias);\n  let ny = d.y / (s.y + bias);\n  let nz = d.z / (s.z + bias);\n  \n  // Return normal for the face with largest value (closest to surface)\n  if (abs(nx) > abs(ny) && abs(nx) > abs(nz)) {\n    return vec3<f32>(sign(nx), 0.0, 0.0);\n  } else if (abs(ny) > abs(nz)) {\n    return vec3<f32>(0.0, sign(ny), 0.0);\n  } else {\n    return vec3<f32>(0.0, 0.0, sign(nz));\n  }\n}\n`;\n\nexport default {\n    wgsl_rotate,\n    wgsl_rotate_y,\n    wgsl_rayStruct,\n    cameraCode,\n    createGetRayFunction,\n    setCameraCode,\n    wgsl_rayToSphere,\n    wgsl_rayToPlane,\n    wgsl_rayToBox,\n    wgsl_material,\n    wgsl_normals\n};\n","// wgsl.js - WGSL template literal with builder pattern\n\nimport { height, width } from './canvas.js';\n\nclass WGSLParser {\n  constructor(code) {\n    this.code = code;\n    this.position = 0;\n    this.functions = [];\n    this.body = [];\n  }\n\n  peek(offset = 0) {\n    return this.code[this.position + offset] || '';\n  }\n\n  advance() {\n    return this.code[this.position++] || '';\n  }\n\n  skipWhitespace() {\n    while (this.position < this.code.length && /\\s/.test(this.peek())) {\n      this.advance();\n    }\n  }\n\n  skipComment() {\n    if (this.peek() === '/' && this.peek(1) === '/') {\n      // Skip single line comment\n      while (this.position < this.code.length && this.peek() !== '\\n') {\n        this.advance();\n      }\n      return true;\n    }\n    if (this.peek() === '/' && this.peek(1) === '*') {\n      // Skip block comment\n      this.advance(); // skip '/'\n      this.advance(); // skip '*'\n      while (this.position < this.code.length - 1) {\n        if (this.peek() === '*' && this.peek(1) === '/') {\n          this.advance(); // skip '*'\n          this.advance(); // skip '/'\n          break;\n        }\n        this.advance();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  skipWhitespaceAndComments() {\n    let skipped = true;\n    while (skipped) {\n      const before = this.position;\n      this.skipWhitespace();\n      this.skipComment();\n      skipped = this.position > before;\n    }\n  }\n\n  readIdentifier() {\n    let result = '';\n    while (this.position < this.code.length && /[a-zA-Z0-9_]/.test(this.peek())) {\n      result += this.advance();\n    }\n    return result;\n  }\n\n  matchKeyword(keyword) {\n    const start = this.position;\n    this.skipWhitespaceAndComments();\n    \n    for (let i = 0; i < keyword.length; i++) {\n      if (this.peek() !== keyword[i]) {\n        this.position = start;\n        return false;\n      }\n      this.advance();\n    }\n    \n    // Make sure it's not part of a longer identifier\n    if (/[a-zA-Z0-9_]/.test(this.peek())) {\n      this.position = start;\n      return false;\n    }\n    \n    return true;\n  }\n\n  findMatchingBrace() {\n    if (this.peek() !== '{') return -1;\n    \n    const start = this.position;\n    this.advance(); // skip opening brace\n    \n    let braceCount = 1;\n    while (this.position < this.code.length && braceCount > 0) {\n      this.skipWhitespaceAndComments();\n      \n      if (this.peek() === '{') {\n        braceCount++;\n        this.advance();\n      } else if (this.peek() === '}') {\n        braceCount--;\n        this.advance();\n      } else if (this.peek() === '\"') {\n        // Skip string literals\n        this.advance(); // skip opening quote\n        while (this.position < this.code.length && this.peek() !== '\"') {\n          if (this.peek() === '\\\\') {\n            this.advance(); // skip escape character\n          }\n          this.advance();\n        }\n        if (this.peek() === '\"') this.advance(); // skip closing quote\n      } else {\n        this.advance();\n      }\n    }\n    \n    return braceCount === 0 ? this.position : -1;\n  }\n\n  parseFunction() {\n    const start = this.position;\n    \n    // Skip 'fn'\n    if (!this.matchKeyword('fn')) return null;\n    \n    this.skipWhitespaceAndComments();\n    \n    // Read function name\n    const name = this.readIdentifier();\n    if (!name) {\n      this.position = start;\n      return null;\n    }\n    \n    this.skipWhitespaceAndComments();\n    \n    // Find parameters\n    if (this.peek() !== '(') {\n      this.position = start;\n      return null;\n    }\n    \n    // Skip to after parameters\n    let parenCount = 1;\n    this.advance(); // skip opening paren\n    while (this.position < this.code.length && parenCount > 0) {\n      if (this.peek() === '(') parenCount++;\n      else if (this.peek() === ')') parenCount--;\n      this.advance();\n    }\n    \n    this.skipWhitespaceAndComments();\n    \n    // Skip return type if present\n    if (this.peek() === '-' && this.peek(1) === '>') {\n      this.advance(); // skip '-'\n      this.advance(); // skip '>'\n      this.skipWhitespaceAndComments();\n      \n      // Skip return type (could be complex like vec4<f32>)\n      while (this.position < this.code.length && \n             this.peek() !== '{' && \n             !/\\s/.test(this.peek())) {\n        if (this.peek() === '<') {\n          // Skip generic parameters\n          let angleCount = 1;\n          this.advance();\n          while (this.position < this.code.length && angleCount > 0) {\n            if (this.peek() === '<') angleCount++;\n            else if (this.peek() === '>') angleCount--;\n            this.advance();\n          }\n        } else {\n          this.advance();\n        }\n      }\n    }\n    \n    this.skipWhitespaceAndComments();\n    \n    // Find function body\n    const bodyEnd = this.findMatchingBrace();\n    if (bodyEnd === -1) {\n      this.position = start;\n      return null;\n    }\n    \n    const functionCode = this.code.slice(start, bodyEnd).trim();\n    return functionCode;\n  }\n\n  parse() {\n    while (this.position < this.code.length) {\n      this.skipWhitespaceAndComments();\n      \n      if (this.position >= this.code.length) break;\n      \n      const fnCode = this.parseFunction();\n      if (fnCode) {\n        this.functions.push(fnCode);\n      } else {\n        // Not a function, add to body\n        const lineStart = this.position;\n        while (this.position < this.code.length && this.peek() !== '\\n') {\n          this.advance();\n        }\n        if (this.peek() === '\\n') this.advance();\n        \n        const line = this.code.slice(lineStart, this.position).trim();\n        if (line) {\n          this.body.push(line);\n        }\n      }\n    }\n    \n    return {\n      functions: this.functions,\n      body: this.body.join('\\n')\n    };\n  }\n}\n\nexport function extractFunctionsAndBody(code) {\n  try {\n    const parser = new WGSLParser(code);\n    return parser.parse();\n  } catch (error) {\n    console.warn('Parser failed, falling back to simple approach:', error);\n    \n    // Fallback: simple splitting approach\n    const lines = code.split('\\n').map(line => line.trim()).filter(line => line);\n    const functions = [];\n    const body = [];\n    \n    let inFunction = false;\n    let braceCount = 0;\n    let currentFunction = [];\n    \n    for (const line of lines) {\n      if (line.startsWith('fn ')) {\n        inFunction = true;\n        currentFunction = [line];\n        braceCount = (line.match(/\\{/g) || []).length - (line.match(/\\}/g) || []).length;\n      } else if (inFunction) {\n        currentFunction.push(line);\n        braceCount += (line.match(/\\{/g) || []).length - (line.match(/\\}/g) || []).length;\n        \n        if (braceCount === 0) {\n          functions.push(currentFunction.join('\\n'));\n          inFunction = false;\n          currentFunction = [];\n        }\n      } else {\n        body.push(line);\n      }\n    }\n    \n    return {\n      functions,\n      body: body.join('\\n')\n    };\n  }\n}\n\nclass WGSLBuilder {\n  constructor() {\n    this.functions = [];\n    this.bindings = [];\n    this.structs = [];\n  }\n\n  fn(name, params, returnType, body) {\n    const fnCode = `fn ${name}(${params}) -> ${returnType} {\\n${body}\\n}`;\n    this.functions.push(fnCode);\n    return this; // for chaining\n  }\n\n  binding(group, binding, type, name) {\n    this.bindings.push(`@group(${group}) @binding(${binding}) var ${name}: ${type};`);\n    return this;\n  }\n\n  struct(name, body) {\n    this.structs.push(`struct ${name} {\\n${body}\\n}`);\n    return this;\n  }\n\n  get main() {\n    // Return a template literal function\n    return (strings, ...values) => {\n      // Build the complete code\n      let code = '';\n      \n      // Add bindings\n      if (this.bindings.length > 0) {\n        code += this.bindings.join('\\n') + '\\n\\n';\n      }\n      \n      // Add structs\n      if (this.structs.length > 0) {\n        code += this.structs.join('\\n\\n') + '\\n\\n';\n      }\n      \n      // Add functions\n      if (this.functions.length > 0) {\n        code += this.functions.join('\\n\\n') + '\\n\\n';\n      }\n      \n      // Add main body from template literal\n      const mainBody = String.raw({ raw: strings }, ...values);\n      code += mainBody;\n      \n      // Check if main function already exists\n      if (/fn\\s+main\\s*\\(/.test(code)) {\n        return code;\n      }\n      \n      // Use existing parser to separate any remaining functions from body\n      const { functions: parsedFunctions, body } = extractFunctionsAndBody(code);\n      \n      // Build final result\n      let result = '';\n      \n      if (parsedFunctions.length > 0) {\n        result += parsedFunctions.join('\\n\\n') + '\\n\\n';\n      }\n      \n      result += '@compute @workgroup_size(1)\\n';\n      result += 'fn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n';\n      \n      if (body) {\n        const indentedBody = body.split('\\n')\n          .map(line => line.trim() ? '  ' + line : line)\n          .join('\\n');\n        result += indentedBody + '\\n';\n      }\n      \n      result += '}';\n      \n      return result;\n    };\n  }\n}\n\n// Original template literal function\nexport function wgsl(strings, ...values) {\n  let code = String.raw({ raw: strings }, ...values);\n\n  // Replace width and height placeholders\n  code = code.replace(/\\bwidth\\b/g, width.toFixed(2));\n  code = code.replace(/\\bheight\\b/g, height.toFixed(2));\n\n  // Remove leading/trailing whitespace but preserve internal structure\n  code = code.trim();\n  \n  // If user already wrote main function, return as-is\n  if (/fn\\s+main\\s*\\(/.test(code)) {\n    return code;\n  }\n  \n  // Extract helper functions and body\n  const { functions, body } = extractFunctionsAndBody(code);\n  \n  // Build the final WGSL code\n  let result = '';\n  \n  // Add functions first\n  if (functions.length > 0) {\n    result += functions.join('\\n\\n') + '\\n\\n';\n  }\n  \n  // Add main function with body\n  result += '@compute @workgroup_size(1)\\n';\n  result += 'fn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n';\n  \n  if (body) {\n    // Indent the body\n    const indentedBody = body.split('\\n')\n      .map(line => line.trim() ? '  ' + line : line)\n      .join('\\n');\n    result += indentedBody + '\\n';\n  }\n  \n  result += '}';\n  \n  return result;\n}\n\n// Add compute builder to wgsl\nwgsl.compute = () => new WGSLBuilder();\n// Allow setting width for parsing stage\nwgsl.setWidth = (value) => { wgsl.width = value; };","/**\n * WebGPU Utils - A utility library for WebGPU development\n * @module webgpu-utils\n */\n\n\n/**\n * Library version\n * @type {string}\n */\nexport const VERSION = '0.1.0';\n\nexport * from './core.js';\nexport * from './canvas.js';\nexport * from './camera.js';\nexport * from './noise.js';\nexport * from './passes.js';\nexport * from './render_passes.js';\nexport * from './struct.js';\nexport * from './raycasting.js';\nexport * from './utilities.js';\nexport * from './wgsl.js';\n"],"names":[],"mappings":"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;AACA;AACA,IAAI,CAAC,CAAC;AACN;;ACtTA;AACA;AACA;AACA;AAGA;AACA,IAAI,WAAW,GAAG,IAAI,CAAC;AACvB;AACA;AACA;AACA;AACA;AACO,SAAS,YAAY,GAAG;AAC/B;AACA,IAAI,IAAI,CAAC,WAAW,EAAE;AACtB,QAAQ,WAAW,GAAG,IAAI,MAAM,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG,IAAI,CAAC,EAAE,aAAa,CAAC,CAAC;AACpH,KAAK;AACL;AACA;AACA,IAAI,OAAO,CAAC;AACZ,IAAI,EAAE,SAAS,CAAC;AAChB,IAAI,EAAE,UAAU,CAAC;AACjB,IAAI,CAAC,CAAC;AACN,CAAC;AACD;AACA;AACA;AACA;AACA;AACY,MAAC,SAAS,GAAG,CAAC;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU;AACvB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;AACH;AACA;AACA;AACA;AACA;AACY,MAAC,UAAU,GAAG,CAAC;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACY,MAAC,OAAO,GAAG,CAAC;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,WAAW,GAAG,CAAC;AAC5B;AACA;AACA;AACA,KAAK,EAAE;AACP;AACA;AACA;AACA;AACA;AACY,MAAC,aAAa,GAAG,CAAC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,EAAE;AACL;AACA;AACA;AACA;AACA;AACY,MAAC,cAAc,GAAG,CAAC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE;AACN;AACA;AACA;AACA;AACA;AACU,IAAC,UAAU,GAAG,CAAC;AACzB;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,oBAAoB,CAAC,OAAO,GAAG,EAAE,EAAE;AACnD,IAAI,MAAM,gBAAgB,GAAG,OAAO,CAAC,gBAAgB,IAAI,UAAU,CAAC;AACpE,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,IAAI,UAAU,CAAC,KAAK,IAAI,IAAI,CAAC;AAC5D,IAAI,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,IAAI,UAAU,CAAC,MAAM,IAAI,IAAI,CAAC;AAC/D;AACA,IAAI,OAAO,CAAC;AACZ;AACA,IAAI,EAAE,gBAAgB,CAAC;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE,KAAK,GAAG,CAAC,CAAC;AAC3C,+BAA+B,EAAE,MAAM,GAAG,CAAC,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACO,SAAS,aAAa,CAAC,IAAI,EAAE;AACpC,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;AAClC,QAAQ,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;AACvE,KAAK;AACL,IAAI,UAAU,GAAG,IAAI,CAAC;AACtB,CAAC;AACD;AACA;AACA;AACA;AACA;AACY,MAAC,gBAAgB,GAAG,CAAC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACY,MAAC,aAAa,GAAG,CAAC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACY,MAAC,aAAa,GAAG,CAAC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACY,MAAC,YAAY,GAAG,CAAC;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvQA;AAGA;AACA,MAAM,UAAU,CAAC;AACjB,EAAE,WAAW,CAAC,IAAI,EAAE;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"}