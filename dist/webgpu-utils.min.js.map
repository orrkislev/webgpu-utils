{"version":3,"file":"webgpu-utils.min.js","sources":["../src/noise.js","../src/struct.js","../src/utilities.js","../src/passes.js","../src/render_passes.js","../src/canvas.js","../src/core.js","../src/raycasting.js","../src/wgsl.js","../src/index.js","../src/camera.js"],"sourcesContent":["/**\n * @file WebGPU shader noise utilities\n * Provides noise functions for WGSL shaders\n */\n\nimport { Buffer } from './core.js';\n\nexport let noiseBuffer;\n\n/**\n * Get WGSL code for noise functions\n * @returns {string} WGSL noise functions code\n */\nexport function getNoiseCode() {\n  // Create a noise offset buffer if it doesn't exist\n  if (!noiseBuffer) {\n    noiseBuffer = new Buffer('noiseOffset', [Math.random() * 1000, Math.random() * 1000, Math.random() * 1000], 'noiseOffset');\n  }\n\n  // Combine noise function implementations\n  return `\n    ${wgslNoise}\n    ${wgslNoise2}\n    `;\n}\n\n/**\n * Simple 1D noise function for WGSL\n * @type {string}\n */\nexport const wgslNoise = `\nfn rand(n: f32) -> f32 { return fract(sin(438.347 * n / 10000)); }\nfn noise1(p: f32) -> f32 {\n  let pVal = p+noiseOffset.x;\n  let fl = floor(pVal);\n  let fc = fract(pVal);\n  return mix(rand(fl), rand(fl + 1.), fc);\n}\n`;\n\n/**\n * 2D simplex noise implementation for WGSL\n * @type {string}\n */\nexport const wgslNoise2 =\n  `fn mod289(x: vec2<f32>) -> vec2<f32> {return x - floor(x * (1. / 289.)) * 289.;}\nfn mod289_3(x: vec3<f32>) -> vec3<f32> {return x - floor(x * (1. / 289.)) * 289.;}\nfn permute3(x: vec3<f32>) -> vec3<f32> {return mod289_3(((x * 34.) + 1.) * x);}\nfn noise2(v: vec2<f32>) -> f32 {\n  let v2 = v + noiseOffset.xy;\n  let C = vec4(\n      0.211324865405187, // (3.0-sqrt(3.0))/6.0\n      0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n      -0.577350269189626, // -1.0 + 2.0 * C.x\n      0.024390243902439 // 1.0 / 41.0\n  );\n  var i = floor(v2 + dot(v2, C.yy));\n  let x0 = v2 - i + dot(i, C.xx);\n  var i1 = select(vec2(0., 1.), vec2(1., 0.), x0.x > x0.y);\n  var x12 = x0.xyxy + C.xxzz;\n  x12.x = x12.x - i1.x;\n  x12.y = x12.y - i1.y;\n  i = mod289(i); // Avoid truncation effects in permutation\n  var p = permute3(permute3(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.));\n  var m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3(0.));\n  m *= m;\n  m *= m;\n  let x = 2. * fract(p * C.www) - 1.;\n  let h = abs(x) - 0.5;\n  let ox = floor(x + 0.5);\n  let a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  let g = vec3(a0.x * x0.x + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw);\n  return 130. * dot(m, g);\n}`;\n\n/**\n * FBM (Fractal Brownian Motion) noise for WGSL\n * @type {string}\n */\nexport const wgslFBM = `\nfn fbm(p: vec2<f32>, octaves: i32) -> f32 {\n    var value = 0.0;\n    var amplitude = 0.5;\n    var frequency = 1.0;\n    var p2 = p + noiseOffset.xy * 10.0;\n    \n    for (var i = 0; i < octaves; i = i + 1) {\n        value += amplitude * noise2(p2 * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    \n    return value;\n}\n`;\n\n/**\n * WGSL function for voronoi noise\n * @type {string}\n */\nexport const wgslVoronoi = `\nfn voronoi(uv: vec2<f32>, scale: f32, seed: f32) -> f32 {\n    let s = scale;\n    let iuv = floor(uv * s);\n    let fuv = fract(uv * s);\n    var min_dist = 1.0;\n    \n    for (var y: i32 = -1; y <= 1; y = y + 1) {\n        for (var x: i32 = -1; x <= 1; x = x + 1) {\n            let neighbor = vec2<f32>(f32(x), f32(y));\n            let point = 0.5 + 0.5 * sin(seed + 6.2831 * rand(rand(iuv.x + neighbor.x + seed) + iuv.y + neighbor.y));\n            let diff = neighbor + point - fuv;\n            let dist = length(diff);\n            min_dist = min(min_dist, dist);\n        }\n    }\n    \n    return min_dist;\n}\n`;\n\nexport default {\n  getNoiseCode,\n  wgslNoise,\n  wgslNoise2,\n  wgslFBM,\n  wgslVoronoi,\n  noiseBuffer\n};\n","import { Buffer } from './core.js';\n\n/**\n * A WebGPU compatible data structure for defining structured buffers\n */\nexport class Struct {\n  /**\n   * Create a new Struct\n   * @param {string} name - The name of the struct in shader code\n   * @param {Array} [data=[]] - Initial data array of {name, type} objects\n   */\n  constructor(name, data = []) {\n    if (typeof name !== 'string' || name.trim() === '') {\n      throw new Error('Struct: Name must be a non-empty string');\n    }\n\n    this.name = name;\n    this.data = data;\n\n    // Add padding if needed to align to vec4 (16 bytes)\n    if (this.floatSize % 4 != 0) {\n      const fillerCount = 4 - (this.floatSize % 4);\n      for (let i = 0; i < fillerCount; i++) {\n        this.data.push({ name: `FILLER___${i}`, type: type_f32 });\n      }\n    }\n  }\n\n  /**\n   * Add a field to the struct\n   * @param {string} name - Field name\n   * @param {Object} type - Field type (one of the predefined types e.g. type_f32, type_vec2)\n   */\n  add(name, type) {\n    if (typeof name !== 'string' || name.trim() === '') {\n      throw new Error('Struct.add: Field name must be a non-empty string');\n    }\n    if (!type || typeof type !== 'object' || !('size' in type)) {\n      throw new Error('Struct.add: Invalid type provided');\n    }\n\n    this.data.push({ name, type });\n  }\n\n  /**\n   * Get the size of the struct in bytes\n   * @returns {number} Size in bytes\n   */\n  get byteSize() {\n    return this.data.reduce((acc, cur) => acc + cur.type.size, 0);\n  }\n\n  /**\n   * Get the size of the struct in float units (4 bytes each)\n   * @returns {number} Size in float units\n   */\n  get floatSize() {\n    return this.byteSize / 4;\n  }\n\n  /**\n   * Get the WGSL code representation of this struct\n   * @returns {string} WGSL struct declaration\n   */\n  get code() {\n    let str = 'struct ' + this.name + ' {\\n';\n    this.data.forEach(({ name, type }) => {\n      str += type.code(name) + ',\\n';\n    });\n    str = str.slice(0, -2); // Remove last comma and newline\n    return str + '\\n};';\n  }\n\n  /**\n   * Create a JavaScript object matching this struct with default values\n   * @returns {Object} Default object instance\n   */\n  object() {\n    const obj = {};\n    this.data.forEach(({ name, type }) => {\n      obj[name] = type.object();\n    });\n    return obj;\n  }\n\n  /**\n   * Convert JavaScript objects to Float32Array for GPU upload\n   * @param {Object|Array} vals - Object(s) to convert\n   * @returns {Float32Array} Packed Float32Array ready for GPU upload\n   * @throws {Error} If input is invalid\n   */\n  toFloat32Array(vals) {\n    if (!vals) {\n      throw new Error('Struct.toFloat32Array: Input values are required');\n    }\n\n    if (!(vals instanceof Array)) vals = [vals];\n    const arr = new Float32Array(this.floatSize * vals.length);\n    let offset = 0;\n\n    vals.forEach((val, i) => {\n      if (!val || typeof val !== 'object') {\n        throw new Error(`Struct.toFloat32Array: Invalid value at index ${i}`);\n      }\n\n      this.data.forEach(({ name, type }) => {\n        const value = val[name];\n        if (value === undefined) {\n          throw new Error(`Struct.toFloat32Array: Missing field ${name} at index ${i}`);\n        }\n\n        if (type instanceof Struct) {\n          arr.set(type.toFloat32Array(value), offset);\n        } else {\n          arr.set(type.toFloat32Array(value), offset);\n        }\n        offset += type.size / 4;\n      });\n    });\n\n    return arr;\n  }\n\n  /**\n   * Convert a Float32Array back to JavaScript objects\n   * @param {Float32Array} arr - Array to convert\n   * @returns {Array} Array of JavaScript objects\n   * @throws {Error} If the input is not a Float32Array\n   */\n  fromFloat32Array(arr) {\n    if (!(arr instanceof Float32Array)) {\n      throw new Error('Struct.fromFloat32Array: Input must be a Float32Array');\n    }\n\n    const vals = [];\n    let offset = 0;\n\n    while (offset < arr.length) {\n      const val = {};\n      this.data.forEach(({ name, type }) => {\n        if (offset + type.size / 4 > arr.length) {\n          throw new Error('Struct.fromFloat32Array: Array too short for struct layout');\n        }\n\n        if (type instanceof Struct) {\n          val[name] = type.fromFloat32Array(arr.slice(offset, offset + type.size / 4));\n        } else {\n          val[name] = type.fromFloat32Array(arr.slice(offset, offset + type.size / 4));\n        }\n        offset += type.size / 4;\n      });\n      vals.push(val);\n    }\n\n    return vals;\n  }\n\n  /**\n   * Create a WebGPU buffer from JavaScript objects\n   * @param {Array|Object} vals - Values to store in the buffer\n   * @param {string} name - Buffer name\n   * @returns {Buffer|Array<Buffer>} Buffer or array of buffers if data exceeds size limit\n   * @throws {Error} If input is invalid\n   */\n  createBuffer(name, vals) {\n    if (!vals) {\n      throw new Error('Struct.createBuffer: Values are required');\n    }\n\n    if (!Array.isArray(vals)) {\n      const newBuffer = new Buffer(name, this.toFloat32Array([vals]));\n      newBuffer.struct = this;\n      return newBuffer;\n    }\n\n    if (vals.length < 1) {\n      throw new Error('Struct.createBuffer: Empty values array');\n    }\n\n    if (vals.length < 65000) {\n      try {\n        const newBuffer = new Buffer(name, this.toFloat32Array(vals));\n        newBuffer.struct = this;\n        newBuffer.isArray = true\n        return newBuffer;\n      } catch (error) {\n        throw new Error(`Struct.createBuffer: Failed to create buffer: ${error.message}`);\n      }\n    }\n\n    // Split into multiple buffers if too large\n    const buffers = [];\n    for (let i = 0; i < vals.length; i += 65000) {\n      const nextData = vals.slice(i, i + 65000);\n      try {\n        const nextBuffer = new Buffer(name, this.toFloat32Array(nextData));\n        nextBuffer.count = nextData.length;\n        nextBuffer.struct = this;\n        nextBuffer.isArray = true;\n        buffers.push(nextBuffer);\n      } catch (error) {\n        throw new Error(`Struct.createBuffer: Failed to create buffer chunk ${i}: ${error.message}`);\n      }\n    }\n    return buffers;\n  }\n}\n\n/**\n * Float (f32) type definition for WGSL\n */\nexport const type_f32 = {\n  size: 4,\n  toFloat32Array: (val) => {\n    if (typeof val !== 'number') {\n      throw new Error('type_f32.toFloat32Array: Expected a number');\n    }\n    return new Float32Array([val]);\n  },\n  fromFloat32Array: (arr) => arr[0],\n  code: (name) => `${name}: f32`,\n  object: () => 0\n};\n\n/**\n * 2D vector (vec2<f32>) type definition for WGSL\n */\nexport const type_vec2 = {\n  size: 8,\n  toFloat32Array: (val) => {\n    if (!val || typeof val !== 'object' || !('x' in val) || !('y' in val)) {\n      throw new Error('type_vec2.toFloat32Array: Expected an object with x and y properties');\n    }\n    return new Float32Array([val.x, val.y]);\n  },\n  fromFloat32Array: (arr) => ({ x: arr[0], y: arr[1] }),\n  code: (name) => `${name}: vec2<f32>`,\n  object: () => ({ x: 0, y: 0 })\n};\n\n/**\n * 3D vector (vec3<f32>) type definition for WGSL\n */\nexport const type_vec3 = {\n  size: 12,\n  toFloat32Array: (val) => {\n    if (!val || typeof val !== 'object' || !('x' in val) || !('y' in val) || !('z' in val)) {\n      throw new Error('type_vec3.toFloat32Array: Expected an object with x, y, and z properties');\n    }\n    return new Float32Array([val.x, val.y, val.z]);\n  },\n  fromFloat32Array: (arr) => ({ x: arr[0], y: arr[1], z: arr[2] }),\n  code: (name) => `${name}: vec3<f32>`,\n  object: () => ({ x: 0, y: 0, z: 0 })\n};\n\n/**\n * 4D vector (vec4<f32>) type definition for WGSL\n */\nexport const type_vec4 = {\n  size: 16,\n  toFloat32Array: (val) => {\n    if (!val || typeof val !== 'object' || !('x' in val) || !('y' in val) || !('z' in val) || !('w' in val)) {\n      throw new Error('type_vec4.toFloat32Array: Expected an object with x, y, z, and w properties');\n    }\n    return new Float32Array([val.x, val.y, val.z, val.w]);\n  },\n  fromFloat32Array: (arr) => ({ x: arr[0], y: arr[1], z: arr[2], w: arr[3] }),\n  code: (name) => `${name}: vec4<f32>`,\n  object: () => ({ x: 0, y: 0, z: 0, w: 0 })\n};\n\n/**\n * RGBA color (vec4<f32>) type definition for WGSL\n * Used for color values with r,g,b,a components\n */\nexport const type_color = {\n  size: 16,\n  toFloat32Array: (val) => {\n    if (!val || typeof val !== 'object' || !('r' in val) || !('g' in val) || !('b' in val) || !('a' in val)) {\n      throw new Error('type_color.toFloat32Array: Expected an object with r, g, b, and a properties');\n    }\n    return new Float32Array([val.r, val.g, val.b, val.a]);\n  },\n  fromFloat32Array: (arr) => ({ r: arr[0], g: arr[1], b: arr[2], a: arr[3] }),\n  code: (name) => `${name}: vec4<f32>`,\n  object: () => ({ r: 0, g: 0, b: 0, a: 1 })\n};\n","import { Buffer } from './core.js';\nimport { Struct, type_f32, type_vec2 } from './struct.js';\nimport { canvas, height, width } from './canvas.js';\n\n/**\n * Generates a random number between two values\n * @param {number} [a=1] - Upper bound (if only one argument is provided) or range\n * @param {number} [b=0] - Lower bound\n * @returns {number} Random number between a and b\n */\nexport const random = (a = 1, b = 0) => Math.random() * (a - b) + b;\n\n/**\n * Selects a random element from an array\n * @param {Array} arr - The array to select from\n * @returns {*} Random element from the array\n * @throws {Error} If the array is empty or not an array\n */\nexport const choose = (arr) => {\n    if (!Array.isArray(arr)) {\n        throw new Error('choose: Expected an array as argument');\n    }\n    if (arr.length === 0) {\n        throw new Error('choose: Cannot select from an empty array');\n    }\n    return arr[Math.floor(random(arr.length))];\n};\n\n/**\n * Creates a promise that resolves after a specified time\n * @param {number} [ms=10] - Milliseconds to wait\n * @returns {Promise} Promise that resolves after the specified time\n */\nexport const timeout = async (ms = 10) => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Maps a value from one range to another\n * @param {number} val - The value to map\n * @param {number} inMin - Input range minimum\n * @param {number} inMax - Input range maximum\n * @param {number} outMin - Output range minimum\n * @param {number} outMax - Output range maximum\n * @returns {number} Mapped value\n */\nexport const map = (val, inMin, inMax, outMin, outMax) =>\n    outMin + (outMax - outMin) * (val - inMin) / (inMax - inMin);\n\n\n/**\n * Creates a mouse position buffer that updates on mouse movement\n * @returns {Buffer} Mouse position buffer with x, y coordinates and button state\n * @throws {Error} If canvas is not defined\n * @example\n * createMouseBuffer();\n * // This will create a buffer that updates with the mouse position and button state\n * @throws {Error} If canvas is not defined\n */\nexport let mouseBuffer = null;\nexport function createMouseBuffer() {\n    if (!canvas) {\n        throw new Error('createMouseBuffer: Canvas is not defined');\n    }\n    const mouseStruct = new Struct('mouseStruct', [\n        { name: 'pos', type: type_vec2 },\n        { name: 'button', type: type_f32 }\n    ])\n    mouseBuffer = mouseStruct.createBuffer('mouse', mouseStruct.object())\n    const mouseEvent = (e) => {\n        const rect = canvas.getBoundingClientRect()\n        const mouseIsDown = e.buttons == 1 ? 0 : 1\n        // mouseBuffer.update(mouseStruct.toFloat32Array([newMouseData]))\n        mouseBuffer.update(new Float32Array([\n            width * (e.clientX - rect.left) / rect.width,\n            height * (e.clientY - rect.top) / rect.height,\n            mouseIsDown\n        ]))\n    }\n    document.addEventListener('mousemove', mouseEvent)\n    document.addEventListener('mousedown', mouseEvent)\n    document.addEventListener('mouseup', mouseEvent)\n}\n\n\n/** * Creates a time buffer that updates with the current time in seconds\n * @returns {Buffer} Time buffer that updates with the current time\n * @example\n * createTimeBuffer();\n * // This will create a buffer that updates with the current time in seconds\n */\nexport let timeBuffer = null;\nexport function getTimeBuffer() {\n    if (!timeBuffer) {\n        throw new Error('getTimeBuffer: Time buffer has not been created yet');\n    }\n    return timeBuffer;\n}\nexport function createTimeBuffer() {\n    timeBuffer = new Buffer('time', new Float32Array([0]))\n    setInterval(() => {\n        timeBuffer.update(new Float32Array([performance.now() / 1000]))\n    }, 1000 / 60) // Update at 60 FPS\n    return timeBuffer\n}","// RenderPass and ComputePass classes extracted from render.js\n\nimport { device, ctx, canvasPresentationFormat, width, height } from './canvas.js';\nimport { noiseBuffer } from './noise.js';\nimport { renderTxtr, feedbackTxtr } from './render_passes.js';\nimport { mouseBuffer, timeBuffer } from './utilities.js';\n\nexport class RenderPass {\n    constructor(texture, code) {\n        if (!device) {\n            throw new Error('RenderPass: WebGPU device not initialized. Call initCanvas() first.');\n        }\n        if (!texture || typeof texture !== 'object') {\n            throw new Error('RenderPass: Invalid texture');\n        }\n        if (typeof code !== 'string' || code.trim() === '') {\n            throw new Error('RenderPass: Shader code must be a non-empty string');\n        }\n        try {\n            this.module = device.createShaderModule({ code });\n            this.pipeline = device.createRenderPipeline({\n                layout: 'auto',\n                vertex: { module: this.module, entryPoint: 'vs' },\n                fragment: { module: this.module, entryPoint: 'fs', targets: [{ format: canvasPresentationFormat }] },\n            });\n            this.sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });\n            this.bindGroup = device.createBindGroup({\n                layout: this.pipeline.getBindGroupLayout(0),\n                entries: [\n                    { binding: 0, resource: this.sampler },\n                    { binding: 1, resource: texture.resource },\n                ],\n            });\n            this.renderPassDescriptor = {\n                colorAttachments: [{ clearValue: [0, 0, 0, 1], loadOp: 'clear', storeOp: 'store' }],\n            };\n        } catch (error) {\n            throw new Error(`Failed to create RenderPass: ${error.message}`);\n        }\n    }\n    run(encoder) {\n        try {\n            this.renderPassDescriptor.colorAttachments[0].view = ctx.getCurrentTexture().createView();\n            const pass = encoder.beginRenderPass(this.renderPassDescriptor);\n            pass.setPipeline(this.pipeline);\n            pass.setBindGroup(0, this.bindGroup);\n            pass.draw(6);\n            pass.end();\n        } catch (error) {\n            throw new Error(`Failed to run RenderPass: ${error.message}`);\n        }\n    }\n}\n\n\nexport class ComputePass {\n    constructor(code, bindings, dispatchSize, entryPoint = 'main') {\n\n        // inject auto-bindings\n        const Auto_Bindings = [\n            { binding: mouseBuffer, regex: /\\bmouse(\\.(pos|button))?\\b/ },\n            { binding: timeBuffer, regex: /\\btime\\b/ },\n            { binding: renderTxtr, regex: /\\brenderTxtr\\b/, function: 'write' },\n            { binding: feedbackTxtr, regex: /\\bfeedbackTxtr\\b/, function: 'read' },\n        ];\n        Auto_Bindings.forEach(auto => {\n            if (code.match(auto.regex)) {\n                if (!bindings.some(b => b.name === auto.binding.name)) {\n                    const newBinding = auto.function ? auto.binding[auto.function]() : auto.binding;\n                    bindings.push(newBinding);\n                }\n            }\n        });\n\n        if (/\\bnoise\\s*\\(|\\bnoise2\\s*\\(|\\bnoise3\\s*\\(/.test(code)) {\n            if (noiseBuffer) bindings.push(noiseBuffer)\n        }\n\n\n        if (bindings.some(b => Array.isArray(b))) {\n            const multipleBuffer = bindings.find(b => Array.isArray(b))\n            const multipleBufferIndex = bindings.findIndex(b => Array.isArray(b))\n            return multipleBuffer.map((buffer, i) => {\n                const newBindings = bindings.slice()\n                newBindings[multipleBufferIndex] = buffer\n                return new ComputePass(code, newBindings, buffer.count, entryPoint)\n            })\n        }\n\n        let bindingsCode = ''\n        bindings.forEach((binding, i) => {\n            bindingsCode += binding.getBindingCode(i) + '\\n';\n        })\n        code = bindingsCode + code;\n\n        bindings.forEach(binding => {\n            if (binding.struct) code = binding.struct.code + '\\n' + code;\n        })\n\n        this.code = code\n\n        this.module = device.createShaderModule({ code });\n        this.pipeline = device.createComputePipeline({\n            layout: 'auto',\n            compute: { module: this.module, entryPoint },\n        });\n        this.bindGroup = device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(0),\n            entries: bindings.map((bind, i) => ({ binding: i, resource: bind.resource })),\n        });\n\n        this.dispatchSize = dispatchSize;\n        if (!Array.isArray(dispatchSize)) this.dispatchSize = [dispatchSize];\n    }\n\n    run(encoder) {\n        const pass = encoder.beginComputePass();\n        pass.setPipeline(this.pipeline);\n        pass.setBindGroup(0, this.bindGroup);\n        pass.dispatchWorkgroups(...this.dispatchSize);\n        pass.end();\n    }\n\n\n\n    /**\n     * Static methods\n     */\n    static texture(code, bindings){\n        return new ComputePass(code, bindings, [width, height]);\n    }\n    static compute(code, bindings, arr){\n        return new ComputePass(code, bindings, [arr.length]);\n    }\n}\n\n/**\n * Execute multiple render or compute passes\n * @param {Array} passes - Array of RenderPass or ComputePass objects (or arrays of passes)\n * @param {number} [repeats=1] - Number of times to repeat the passes\n * @throws {Error} If device is not initialized or passes are invalid\n */\nexport function runPasses(passes, repeats = 1) {\n    if (!device) {\n        throw new Error('runPasses: WebGPU device not initialized. Call initCanvas() first.');\n    }\n\n    if (!Array.isArray(passes))\n        passes = [passes];\n\n    try {\n        const commandEncoder = device.createCommandEncoder();\n        for (let i = 0; i < repeats; i++) {\n            for (const pass of passes) {\n                if (Array.isArray(pass)) {\n                    pass.forEach(p => {\n                        if (!p || typeof p.run !== 'function') {\n                            throw new Error('Invalid pass object in array');\n                        }\n                        p.run(commandEncoder);\n                    });\n                } else {\n                    if (!pass || typeof pass.run !== 'function') {\n                        throw new Error('Invalid pass object');\n                    }\n                    pass.run(commandEncoder);\n                }\n            }\n        }\n        device.queue.submit([commandEncoder.finish()]);\n    } catch (error) {\n        throw new Error(`Failed to run passes: ${error.message}`);\n    }\n}","/**\n * @file WebGPU render passes for common operations\n * Provides specialized render passes for common rendering tasks\n */\n\nimport { RenderPass, ComputePass, runPasses } from './passes.js';\nimport { Texture } from './core.js';\nimport { width, height } from './canvas.js';\n\n/**\n * Global rendering parameters\n * @type {Object}\n */\nconst renderParams = {\n    bgColor: [0, 0, 0]\n};\n\n/**\n * Texture array for render targets\n * @type {Array}\n */\nexport let renderTxtr, feedbackTxtr\nexport let renderPass, matchPass, clearPass;\n\n/**\n * Creates a standard render pass for displaying to screen\n * @async\n * @param {Object} [options] - Render pass options\n * @param {Array<number>} [options.bgColor] - Background color [r, g, b] (0-255)\n * @returns {Promise<RenderPass>} The configured render pass\n */\nexport async function createRenderPass(options = {}) {\n    if (options.bgColor) {\n        renderParams.bgColor = options.bgColor;\n    }\n\n    await createTextures();\n\n    createClearPass()\n\n    renderPass = new RenderPass(renderTxtr, basicRenderCode);\n    return renderPass;\n}\n\n/**\n * Creates textures for rendering\n * @async\n * @returns {Promise<void>}\n */\nexport async function createTextures() {\n    try {\n        renderTxtr = new Texture('renderTxtr', width, height);\n        feedbackTxtr = new Texture('feedbackTxtr', width, height);\n\n        const code = `\n        @compute @workgroup_size(1)\n        fn main(@builtin(global_invocation_id) id: vec3<u32>) {\n          let x: i32 = i32(id.x);\n          let y: i32 = i32(id.y);\n          let clr = vec4f(${renderParams.bgColor[0] / 255},${renderParams.bgColor[1] / 255},${renderParams.bgColor[2] / 255},1.0);\n          textureStore(renderTxtr, vec2<i32>(x, y), clr);\n          textureStore(feedbackTxtr, vec2<i32>(x, y), clr);\n        }`;\n\n        const pass1 = new ComputePass(code, [renderTxtr.write(), feedbackTxtr.write()], [width, height]);\n        runPasses([pass1]);\n    } catch (error) {\n        throw new Error(`Failed to create textures: ${error.message}`);\n    }\n}\n\n/**\n * Basic render code for fullscreen quad rendering\n * @type {string}\n */\nexport const basicRenderCode = `\n    struct OurVertexShaderOutput {\n        @builtin(position) position: vec4f,\n        @location(0) uv: vec2f,\n    };\n\n    @vertex fn vs(@builtin(vertex_index) vertexIndex: u32) -> OurVertexShaderOutput {\n        let pos = array(\n            vec2f(-1.0, -1.0), vec2f(1.0, -1.0),\n            vec2f(-1.0, 1.0), vec2f(-1.0, 1.0),\n            vec2f(1.0, -1.0), vec2f(1.0, 1.0),\n        );\n\n        var vsOutput: OurVertexShaderOutput;\n        let xy = pos[vertexIndex];\n        vsOutput.position = vec4f(xy, 0.0, 1.0);\n        vsOutput.uv = vec2f((xy.x + 1.0) / 2.0, 1.0-(xy.y + 1.0) / 2.0);\n        return vsOutput;\n    }\n\n    @group(0) @binding(0) var ourSampler: sampler;\n    @group(0) @binding(1) var ourTexture: texture_2d<f32>;\n\n    @fragment fn fs(fsInput: OurVertexShaderOutput) -> @location(0) vec4f {\n        return textureSample(ourTexture, ourSampler, fsInput.uv);\n    }\n    `;\n\n/**\n * Creates a pass that matches/copies one texture to another\n * @async\n * @returns {Promise<ComputePass>} The configured compute pass\n */\nexport async function createMatchPass() {\n    if (!renderTxtr || !feedbackTxtr) {\n        throw new Error('createMatchPass: Textures must be created first with createTextures()');\n    }\n\n    const code = `\n    @compute @workgroup_size(1)\n    fn main(@builtin(global_invocation_id) id: vec3<u32>) {\n      let x: i32 = i32(id.x);\n      let y: i32 = i32(id.y);\n      let clr = textureLoad(renderTxtr, vec2<i32>(x, y), 0);\n      textureStore(feedbackTxtr, vec2<i32>(x, y), vec4<f32>(clr.r, clr.g, clr.b, 1.0));\n    }`;\n\n    matchPass = new ComputePass(code, [renderTxtr.read(), feedbackTxtr.write()], [width, height]);\n    return matchPass;\n}\n\n/**\n * Creates a pass that clears all textures to the background color\n * @async\n * @returns {Promise<ComputePass>} The configured compute pass\n */\nexport async function createClearPass() {\n    if (!renderTxtr || !feedbackTxtr) {\n        throw new Error('createClearPass: Textures must be created first with createTextures()');\n    }\n\n    const code = `\n    @compute @workgroup_size(1)\n    fn main(@builtin(global_invocation_id) id: vec3<u32>) {\n      let x: i32 = i32(id.x);\n      let y: i32 = i32(id.y);\n\n      var clr = vec4<f32>(${renderParams.bgColor[0] / 255}, ${renderParams.bgColor[1] / 255}, ${renderParams.bgColor[2] / 255}, 1.0);\n\n      textureStore(renderTxtr, vec2<i32>(x, y), clr);\n      textureStore(feedbackTxtr, vec2<i32>(x, y), clr);\n    }`;\n\n    clearPass = new ComputePass(code, [renderTxtr.write(), feedbackTxtr.write()], [width, height]);\n    return clearPass;\n}\n\n/**\n * Set background color and update render parameters\n * @param {Array<number>} color - RGB color values [0-255]\n */\nexport function setBackgroundColor(color) {\n    if (!Array.isArray(color) || color.length < 3) {\n        throw new Error('setBackgroundColor: Expected an array of at least 3 RGB values [0-255]');\n    }\n\n    renderParams.bgColor = color.map(v => Math.max(0, Math.min(255, v)));\n}\n\nexport default {\n    renderParams,\n    createRenderPass,\n    createTextures,\n    basicRenderCode,\n    createMatchPass,\n    createClearPass,\n    setBackgroundColor\n};\n","/**\n * @file WebGPU canvas initialization and rendering utilities\n * Provides functions to initialize a WebGPU canvas, set up the rendering context,\n * and handle basic rendering operations.\n */\n\nimport { createMatchPass, createRenderPass } from \"./render_passes\";\nimport { createMouseBuffer, createTimeBuffer } from \"./utilities\";\n\nexport let width, height, device;\nexport let canvas, canvasPresentationFormat, ctx;\n\n/**\n * Initialize the WebGPU canvas and device\n * @param {Object} [options] - Canvas initialization options\n * @param {number} [options.width] - Canvas width (defaults to window width * 2)\n * @param {number} [options.height] - Canvas height (defaults to window height * 2)\n * @param {HTMLCanvasElement} [options.canvas] - Existing canvas to use (creates one if not provided)\n * @param {string} [options.containerId] - ID of the container to append the canvas to and size it to\n * @returns {Promise<{device: GPUDevice, canvas: HTMLCanvasElement, width: number, height: number}>}\n * @throws {Error} If WebGPU is not supported or initialization fails\n */\nexport async function initCanvas(options = {}) {\n    if (!navigator.gpu) {\n        webgpu_notSupported(options, 'WebGPU is not supported in this browser.');\n    }\n\n    try {\n        const adapter = await navigator.gpu?.requestAdapter();\n        if (!adapter) {\n            webgpu_notSupported(options, 'Couldn\\'t request WebGPU adapter.');\n        }\n\n        device = await adapter.requestDevice();\n        if (!device) {\n            webgpu_notSupported(options, 'Couldn\\'t request WebGPU device.');\n        }\n\n        // Set up error handling for device\n        device.addEventListener('uncapturederror', (event) => {\n            console.error('WebGPU device error:', event.error);\n        });\n\n        // Get or create canvas\n        canvas = options.canvas || document.querySelector('canvas');\n        if (!canvas) {\n            canvas = document.createElement('canvas');\n        }\n\n        let container = null;\n        if (options.containerId) {\n            container = document.getElementById(options.containerId);\n            if (!container) {\n                throw new Error(`Container with ID '${options.containerId}' not found.`);\n            }\n            container.appendChild(canvas);\n            width = container.clientWidth;\n            height = container.clientHeight;\n            canvas.style.display = 'block';\n        } else {\n            if (!options.canvas) {\n                document.body.appendChild(canvas);\n            }\n            width = window.innerWidth;\n            height = window.innerHeight;\n        }\n\n        if (options.width) width = options.width;\n        if (options.height) height = options.height;\n\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n        width *= 2\n        height *= 2\n        canvas.width = width;\n        canvas.height = height;\n\n        // Configure WebGPU context\n        ctx = canvas.getContext('webgpu');\n        if (!ctx) {\n            throw new Error('Couldn\\'t get WebGPU context from canvas.');\n        }\n\n        canvasPresentationFormat = navigator.gpu.getPreferredCanvasFormat();\n        ctx.configure({\n            device,\n            format: canvasPresentationFormat,\n            alphaMode: 'premultiplied'\n        });\n\n        // Add keyboard shortcut for saving canvas\n        window.addEventListener('keydown', (e) => {\n            if (e.key === 's') {\n                const a = document.createElement('a');\n                a.href = canvas.toDataURL();\n                a.download = 'webgpu-image-' + new Date().toISOString().replace(/:/g, '-') + '.png';\n                a.click();\n            }\n        });\n\n        // In your WebGPU initialization (e.g. after device, ctx, canvasPresentationFormat are set):\n        // _setWebGPUContext(device, ctx, canvasPresentationFormat);\n\n        // Export reference variables to global scope for convenience\n        return { device, canvas, width, height };\n    } catch (error) {\n        throw new Error(`Failed to initialize canvas: ${error.message}`);\n    }\n}\n\n// Check if WebGPU is supported in the current browser\nexport function isWebGPUSupported() {\n    return typeof navigator !== 'undefined' && navigator && ('gpu' in navigator);\n}\n\n// Utility to create a promise that resolves when the DOM is loaded\nexport function domReady() {\n    return new Promise(resolve => {\n        if (document.readyState === 'complete' || document.readyState === 'interactive') {\n            resolve();\n        } else {\n            document.addEventListener('DOMContentLoaded', () => resolve());\n        }\n    });\n}\n\n// Initialize the library and canvas in one call\nexport async function init(options = {}) {\n    await domReady();\n    await initCanvas(options);\n    if (options.mouse) createMouseBuffer();\n    if (options.time) createTimeBuffer();\n    createRenderPass();\n    if (options.feedback) createMatchPass();\n}\n\n\n\n\nfunction webgpu_notSupported(options, error) {\n    const element = document.createElement('div');\n    element.style = `\n        width: 100%;\n        height: 100%;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        font-size: 24px;\n        color: white;\n        background-color: black;\n    `;\n    element.innerText = 'WebGPU is not supported in this browser.';\n    if (options.containerId) {\n        const container = document.getElementById(options.containerId);\n        if (container) {\n            container.appendChild(element);\n        } else {\n            console.warn(`Container with ID '${options.containerId}' not found.`);\n        }\n    } else {\n        document.body.appendChild(element);\n    }\n    return new Error(error)\n}","/**\n * WebGPU Core Module\n * Provides basic WebGPU functionality including buffer and texture creation.\n * This module is designed to be used with the WebGPU API and requires a compatible browser.\n */\n\nimport { device } from './canvas.js';\n\n/**\n * Create WebGPU buffer\n * @class\n */\nexport class Buffer {\n    /**\n     * Create a WebGPU buffer\n     * @param {string} [name=''] - Name for the buffer\n     * @param {Float32Array|Array} data - Data to store in buffer\n     * @throws {Error} If device is not initialized or buffer creation fails\n     */\n    constructor(name, data) {\n        if (!device) {\n            throw new Error('Buffer: WebGPU device not initialized. Call initCanvas() first.');\n        }\n\n        try {\n            this.name = name;\n\n            // Convert array to Float32Array if needed\n            if (Array.isArray(data)) {\n                data = new Float32Array(data);\n            } else if (!(data instanceof Float32Array)) {\n                throw new Error('Buffer: Data must be an Array or Float32Array');\n            }\n\n            this.data = data;\n            this.size = data.byteLength;\n\n            // Create the GPU buffer\n            this.buffer = device.createBuffer({\n                label: this.name,\n                size: this.size,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n                mappedAtCreation: true\n            });\n\n            // Write data to the buffer\n            new Float32Array(this.buffer.getMappedRange()).set(data);\n            this.buffer.unmap();\n\n            // Create resource binding\n            this.resource = { buffer: this.buffer };\n        } catch (error) {\n            throw new Error(`Failed to create Buffer: ${error.message}`);\n        }\n    }\n\n    /**\n     * Update buffer data\n     * @param {Float32Array|Array} data - New data for the buffer\n     */\n    update(data) {\n        if (!data || (!Array.isArray(data) && !(data instanceof Float32Array))) {\n            throw new Error('Buffer.update: Data must be an Array or Float32Array');\n        }\n\n        try {\n            // Convert array to Float32Array if needed\n            if (Array.isArray(data)) {\n                data = new Float32Array(data);\n            }\n\n            // Update data\n            device.queue.writeBuffer(this.buffer, 0, data);\n            this.data = data;\n        } catch (error) {\n            throw new Error(`Failed to update Buffer: ${error.message}`);\n        }\n    }\n\n    /**\n     * Get binding code for this buffer\n     * @param {number} index - Binding index for the buffer\n     * @returns {string} WGSL binding code for the buffer\n     * @throws {Error} If buffer resource is not initialized\n     */\n    getBindingCode(index) {\n        if (!this.resource || !this.resource.buffer) {\n            throw new Error('Buffer.getBindingCode: Buffer resource not initialized');\n        }\n\n        let bufferType = 'f32';\n        if (this.struct) bufferType = this.struct.name;\n        else {\n            if (this.size == 4) bufferType = 'f32';\n            else if (this.size == 8) bufferType = 'vec2f';\n            else if (this.size == 12) bufferType = 'vec3f';\n            else if (this.size == 16) bufferType = 'vec4f';\n        }\n        if (this.isArray) bufferType = `array<${bufferType}>`;\n        return `@group(0) @binding(${index}) var<storage, read_write> ${this.name}: ${bufferType};`\n    }\n\n    async getData(){\n        // get the data from the buffer\n        const readBuffer = device.createBuffer({\n            size: this.size,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n\n        // Step 2: Create a command encoder and copy the buffer\n        const commandEncoder = device.createCommandEncoder();\n        commandEncoder.copyBufferToBuffer(\n            this.buffer, // source buffer\n            0,           // source offset\n            readBuffer,  // destination buffer\n            0,           // destination offset\n            this.size    // size\n        );\n\n        // Submit the commands\n        const commands = commandEncoder.finish();\n        device.queue.submit([commands]);\n\n        // Step 3: Map the read buffer and read the data\n        await readBuffer.mapAsync(GPUMapMode.READ);\n        const copyArrayBuffer = readBuffer.getMappedRange();\n\n        // Assuming the data is float32\n        const newdata = [...new Float32Array(copyArrayBuffer)]\n\n        // Don't forget to unmap the buffer\n        readBuffer.unmap();\n        return newdata\n    }\n}\n\n/**\n * WebGPU Texture wrapper\n * @class\n */\nexport class Texture {\n    /**\n     * Create a WebGPU texture\n     * @param {string} [name=''] - Name for the texture\n     * @param {number} [width=512] - Texture width\n     * @param {number} [height=512] - Texture height\n     * @param {GPUTextureFormat} [format='rgba8unorm'] - Texture format\n     * @throws {Error} If device is not initialized or texture creation fails\n     */\n    constructor(name = '', width = 512, height = 512, format = 'rgba8unorm') {\n        if (!device) {\n            throw new Error('Texture: WebGPU device not initialized. Call initCanvas() first.');\n        }\n\n        try {\n            this.name = name;\n            this.width = width;\n            this.height = height;\n            this.format = format;\n\n            // Create the texture\n            this.texture = device.createTexture({\n                label: this.name,\n                size: [width, height, 1],\n                format,\n                usage: GPUTextureUsage.COPY_DST |\n                    GPUTextureUsage.STORAGE_BINDING |\n                    GPUTextureUsage.TEXTURE_BINDING\n            });\n\n            // Create texture view\n            this.view = this.texture.createView();\n            this.resource = this.view;\n        } catch (error) {\n            throw new Error(`Failed to create Texture: ${error.message}`);\n        }\n    }\n\n    /**\n     * Get binding for this texture in read mode\n     * @returns {GPUTextureView} Texture view for binding\n     */\n    read() {\n        return new TextureBindingHelper(this, 'read');\n    }\n\n    /**\n     * Get binding for this texture in write mode\n     * @returns {GPUTextureView} Texture view for binding\n     */\n    write() {\n        return new TextureBindingHelper(this, 'write');\n    }\n}\nfunction TextureBindingHelper(texture, readOrWrite = 'read') {\n    this.texture = texture;\n    this.readOrWrite = readOrWrite;\n    this.resource = texture.resource\n    this.name = texture.name;\n\n    this.getBindingCode = (bindingIndex) => {\n        if (this.readOrWrite === 'read' && this.texture.format == 'rgba8unorm') {\n            return `@group(0) @binding(${bindingIndex}) var ${this.texture.name}: texture_2d<f32>;`\n        }\n        return `@group(0) @binding(${bindingIndex}) var ${this.texture.name}: texture_storage_2d<${this.texture.format}, ${this.readOrWrite}>;`\n    }\n}\n","/**\n * @file WebGPU ray casting utilities for WGSL shaders\n * Provides helper functions for ray-based rendering techniques\n */\n\n/**\n * WGSL code for 2D vector rotation\n * @type {string}\n */\nexport const wgsl_rotate = `fn rotate(v: vec2<f32>, a: f32) -> vec2<f32> {\n    let s = sin(a);\n    let c = cos(a);\n    return vec2<f32>(c * v.x - s * v.y, s * v.x + c * v.y);\n    }`;\n\n/**\n * WGSL code for rotating a vector around the Y axis\n * @type {string}\n */\nexport const wgsl_rotate_y = `fn rotate_y(vec: vec3<f32>, angle: f32) -> vec3<f32> {\n      let cos_theta = cos(angle);\n      let sin_theta = sin(angle);\n      return vec3<f32>(\n          vec.x * cos_theta + vec.z * sin_theta,\n          vec.y,\n          -vec.x * sin_theta + vec.z * cos_theta\n      );\n  }`;\n\n/**\n * WGSL struct definitions for ray casting\n * @type {string}\n */\nexport const wgsl_rayStruct = `\n  struct hit {\n    dist: f32,\n    index: i32,\n  };\n\n  struct Ray {\n    ro: vec3<f32>,\n    rd: vec3<f32>,\n  };`;\n\n/**\n * Default camera code for ray generation\n * @type {string}\n */\nexport let cameraCode = `\n  let theta = 0.0;\n  let camPos = vec3<f32>(0.0, 0.0, 1000.0);\n`;\n\n/**\n * Creates a WGSL function for ray generation\n * @param {Object} [options] - Options for ray generation\n * @param {string} [options.customCameraCode] - Custom camera setup code\n * @param {number} [options.width] - Canvas width\n * @param {number} [options.height] - Canvas height\n * @returns {string} WGSL function for ray generation\n */\nexport function createGetRayFunction(options = {}) {\n    const customCameraCode = options.customCameraCode || cameraCode;\n    const width = options.width || globalThis.width || 1000;\n    const height = options.height || globalThis.height || 1000;\n\n    return `\nfn getRay(x: i32, y: i32) -> Ray {\n    ${customCameraCode}\n    camPos = rotate_y(camPos, theta);\n    let lookAt = vec3<f32>(0.0, 0.0, 0.0);\n    let forward = normalize(lookAt - camPos);\n\n    // Calculate right vector (perpendicular to forward and world up)\n    let worldUp = vec3<f32>(0.0, 1.0, 0.0);\n    let right = normalize(cross(forward, worldUp));\n\n    // Calculate camera's up vector\n    let up = normalize(cross(right, forward));\n\n    // Screen coordinates relative to center\n    let screenX = f32(x) / 2 - ${width / 4};\n    let screenY = f32(y) / 2 - ${height / 4};\n\n    // Scale factors to control orthographic view size\n    let orthoScale = 1.0; // Adjust as needed\n\n    // For orthographic, we offset the ray origin in the plane perpendicular to viewing direction\n    let ro = camPos + (right * screenX * orthoScale) + (up * screenY * orthoScale);\n\n    // All rays have the same direction (parallel)\n    let rd = forward;\n\n    return Ray(ro, rd);\n  }\n`;\n}\n\n/**\n * Sets custom camera code for ray generation\n * @param {string} code - WGSL camera initialization code\n */\nexport function setCameraCode(code) {\n    if (typeof code !== 'string') {\n        throw new Error('setCameraCode: Camera code must be a string');\n    }\n    cameraCode = code;\n}\n\n/**\n * WGSL code for ray-sphere intersection tests\n * @type {string}\n */\nexport const wgsl_rayToSphere = `\nfn rayToSphere(ro: vec3<f32>, rd: vec3<f32>, sph: sphere) -> f32 {\n    let oc = ro - sph.pos;\n    // Since rd is typically normalized, a = dot(rd,rd) = 1.0\n    \n    let b = dot(oc, rd);\n    let c = dot(oc, oc) - sph.r * sph.r;\n    let discriminant = b * b - c;\n    \n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n\n    let t1 = -b - sqrt(discriminant);\n    let t2 = -b + sqrt(discriminant);\n\n    if (t1 > 0.0) {\n      return t1;\n    }\n    if (t2 > 0.0) {\n      return t2;\n    } else {\n      return -1.0;\n    }\n}\nfn isInSphere(pos: vec3<f32>, sph: sphere) -> bool {\n  return length(pos - sph.pos) <= sph.r;\n}\n`;\n\n/**\n * WGSL code for ray-plane intersection tests\n * @type {string}\n */\nexport const wgsl_rayToPlane = `\nstruct Plane {\n  normal: vec3<f32>,\n  distance: f32,\n};\n\nfn rayToPlane(ro: vec3<f32>, rd: vec3<f32>, plane: Plane) -> f32 {\n  let denom = dot(plane.normal, rd);\n  \n  // Check if ray is parallel to the plane\n  if (abs(denom) < 0.0001) {\n    return -1.0;\n  }\n  \n  let t = -(dot(ro, plane.normal) + plane.distance) / denom;\n  \n  // Only return positive intersection distance (in front of the ray)\n  if (t < 0.0) {\n    return -1.0;\n  }\n  \n  return t;\n}\n`;\n\n/**\n * WGSL code for ray-box intersection tests\n * @type {string}\n */\nexport const wgsl_rayToBox = `\nstruct Box {\n  min: vec3<f32>,\n  max: vec3<f32>,\n};\n\nfn rayToBox(ro: vec3<f32>, rd: vec3<f32>, box: Box) -> f32 {\n  let tMin = (box.min - ro) / rd;\n  let tMax = (box.max - ro) / rd;\n  \n  let t1 = min(tMin, tMax);\n  let t2 = max(tMin, tMax);\n  \n  let tNear = max(max(t1.x, t1.y), t1.z);\n  let tFar = min(min(t2.x, t2.y), t2.z);\n  \n  // Box is behind the ray or ray misses box\n  if (tNear > tFar || tFar < 0.0) {\n    return -1.0;\n  }\n  \n  // Return nearest positive hit\n  return tNear > 0.0 ? tNear : tFar;\n}\n\nfn isInBox(pos: vec3<f32>, box: Box) -> bool {\n  return all(pos >= box.min) && all(pos <= box.max);\n}\n`;\n\n/**\n * WGSL material definition for use with ray tracing\n * @type {string}\n */\nexport const wgsl_material = `\nstruct Material {\n  albedo: vec3<f32>,\n  roughness: f32,\n  metallic: f32,\n  emission: vec3<f32>,\n  ior: f32,\n};\n\nfn defaultMaterial() -> Material {\n  return Material(\n    vec3<f32>(0.8, 0.8, 0.8), // albedo (diffuse color)\n    0.5,                       // roughness\n    0.0,                       // metallic\n    vec3<f32>(0.0, 0.0, 0.0), // emission\n    1.45                       // index of refraction\n  );\n}\n`;\n\n/**\n * WGSL code for calculating surface normals\n * @type {string}\n */\nexport const wgsl_normals = `\nfn sphereNormal(hitPos: vec3<f32>, sphere: sphere) -> vec3<f32> {\n  return normalize(hitPos - sphere.pos);\n}\n\nfn planeNormal(plane: Plane) -> vec3<f32> {\n  return plane.normal;\n}\n\nfn boxNormal(hitPos: vec3<f32>, box: Box) -> vec3<f32> {\n  // Find the face that was hit by checking which component is closest to the respective face\n  let center = (box.min + box.max) * 0.5;\n  let d = hitPos - center;\n  let s = (box.max - box.min) * 0.5;\n  \n  let bias = 0.0001; // Small bias to avoid precision errors\n  let nx = d.x / (s.x + bias);\n  let ny = d.y / (s.y + bias);\n  let nz = d.z / (s.z + bias);\n  \n  // Return normal for the face with largest value (closest to surface)\n  if (abs(nx) > abs(ny) && abs(nx) > abs(nz)) {\n    return vec3<f32>(sign(nx), 0.0, 0.0);\n  } else if (abs(ny) > abs(nz)) {\n    return vec3<f32>(0.0, sign(ny), 0.0);\n  } else {\n    return vec3<f32>(0.0, 0.0, sign(nz));\n  }\n}\n`;\n\nexport default {\n    wgsl_rotate,\n    wgsl_rotate_y,\n    wgsl_rayStruct,\n    cameraCode,\n    createGetRayFunction,\n    setCameraCode,\n    wgsl_rayToSphere,\n    wgsl_rayToPlane,\n    wgsl_rayToBox,\n    wgsl_material,\n    wgsl_normals\n};\n","// wgsl.js - WGSL template literal with builder pattern\n\nimport { height, width } from './canvas.js';\nimport { getNoiseCode } from './noise.js';\n\nclass WGSLParser {\n  constructor(code) {\n    this.code = code;\n    this.position = 0;\n    this.functions = [];\n    this.body = [];\n  }\n\n  peek(offset = 0) {\n    return this.code[this.position + offset] || '';\n  }\n\n  advance() {\n    return this.code[this.position++] || '';\n  }\n\n  skipWhitespace() {\n    while (this.position < this.code.length && /\\s/.test(this.peek())) {\n      this.advance();\n    }\n  }\n\n  skipComment() {\n    if (this.peek() === '/' && this.peek(1) === '/') {\n      // Skip single line comment\n      while (this.position < this.code.length && this.peek() !== '\\n') {\n        this.advance();\n      }\n      return true;\n    }\n    if (this.peek() === '/' && this.peek(1) === '*') {\n      // Skip block comment\n      this.advance(); // skip '/'\n      this.advance(); // skip '*'\n      while (this.position < this.code.length - 1) {\n        if (this.peek() === '*' && this.peek(1) === '/') {\n          this.advance(); // skip '*'\n          this.advance(); // skip '/'\n          break;\n        }\n        this.advance();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  skipWhitespaceAndComments() {\n    let skipped = true;\n    while (skipped) {\n      const before = this.position;\n      this.skipWhitespace();\n      this.skipComment();\n      skipped = this.position > before;\n    }\n  }\n\n  readIdentifier() {\n    let result = '';\n    while (this.position < this.code.length && /[a-zA-Z0-9_]/.test(this.peek())) {\n      result += this.advance();\n    }\n    return result;\n  }\n\n  matchKeyword(keyword) {\n    const start = this.position;\n    this.skipWhitespaceAndComments();\n    \n    for (let i = 0; i < keyword.length; i++) {\n      if (this.peek() !== keyword[i]) {\n        this.position = start;\n        return false;\n      }\n      this.advance();\n    }\n    \n    // Make sure it's not part of a longer identifier\n    if (/[a-zA-Z0-9_]/.test(this.peek())) {\n      this.position = start;\n      return false;\n    }\n    \n    return true;\n  }\n\n  findMatchingBrace() {\n    if (this.peek() !== '{') return -1;\n    \n    const start = this.position;\n    this.advance(); // skip opening brace\n    \n    let braceCount = 1;\n    while (this.position < this.code.length && braceCount > 0) {\n      this.skipWhitespaceAndComments();\n      \n      if (this.peek() === '{') {\n        braceCount++;\n        this.advance();\n      } else if (this.peek() === '}') {\n        braceCount--;\n        this.advance();\n      } else if (this.peek() === '\"') {\n        // Skip string literals\n        this.advance(); // skip opening quote\n        while (this.position < this.code.length && this.peek() !== '\"') {\n          if (this.peek() === '\\\\') {\n            this.advance(); // skip escape character\n          }\n          this.advance();\n        }\n        if (this.peek() === '\"') this.advance(); // skip closing quote\n      } else {\n        this.advance();\n      }\n    }\n    \n    return braceCount === 0 ? this.position : -1;\n  }\n\n  parseFunction() {\n    const start = this.position;\n    \n    // Skip 'fn'\n    if (!this.matchKeyword('fn')) return null;\n    \n    this.skipWhitespaceAndComments();\n    \n    // Read function name\n    const name = this.readIdentifier();\n    if (!name) {\n      this.position = start;\n      return null;\n    }\n    \n    this.skipWhitespaceAndComments();\n    \n    // Find parameters\n    if (this.peek() !== '(') {\n      this.position = start;\n      return null;\n    }\n    \n    // Skip to after parameters\n    let parenCount = 1;\n    this.advance(); // skip opening paren\n    while (this.position < this.code.length && parenCount > 0) {\n      if (this.peek() === '(') parenCount++;\n      else if (this.peek() === ')') parenCount--;\n      this.advance();\n    }\n    \n    this.skipWhitespaceAndComments();\n    \n    // Skip return type if present\n    if (this.peek() === '-' && this.peek(1) === '>') {\n      this.advance(); // skip '-'\n      this.advance(); // skip '>'\n      this.skipWhitespaceAndComments();\n      \n      // Skip return type (could be complex like vec4<f32>)\n      while (this.position < this.code.length && \n             this.peek() !== '{' && \n             !/\\s/.test(this.peek())) {\n        if (this.peek() === '<') {\n          // Skip generic parameters\n          let angleCount = 1;\n          this.advance();\n          while (this.position < this.code.length && angleCount > 0) {\n            if (this.peek() === '<') angleCount++;\n            else if (this.peek() === '>') angleCount--;\n            this.advance();\n          }\n        } else {\n          this.advance();\n        }\n      }\n    }\n    \n    this.skipWhitespaceAndComments();\n    \n    // Find function body\n    const bodyEnd = this.findMatchingBrace();\n    if (bodyEnd === -1) {\n      this.position = start;\n      return null;\n    }\n    \n    const functionCode = this.code.slice(start, bodyEnd).trim();\n    return functionCode;\n  }\n\n  parse() {\n    while (this.position < this.code.length) {\n      this.skipWhitespaceAndComments();\n      \n      if (this.position >= this.code.length) break;\n      \n      const fnCode = this.parseFunction();\n      if (fnCode) {\n        this.functions.push(fnCode);\n      } else {\n        // Not a function, add to body\n        const lineStart = this.position;\n        while (this.position < this.code.length && this.peek() !== '\\n') {\n          this.advance();\n        }\n        if (this.peek() === '\\n') this.advance();\n        \n        const line = this.code.slice(lineStart, this.position).trim();\n        if (line) {\n          this.body.push(line);\n        }\n      }\n    }\n    \n    return {\n      functions: this.functions,\n      body: this.body.join('\\n')\n    };\n  }\n}\n\nexport function extractFunctionsAndBody(code) {\n  try {\n    const parser = new WGSLParser(code);\n    return parser.parse();\n  } catch (error) {\n    console.warn('Parser failed, falling back to simple approach:', error);\n    \n    // Fallback: simple splitting approach\n    const lines = code.split('\\n').map(line => line.trim()).filter(line => line);\n    const functions = [];\n    const body = [];\n    \n    let inFunction = false;\n    let braceCount = 0;\n    let currentFunction = [];\n    \n    for (const line of lines) {\n      if (line.startsWith('fn ')) {\n        inFunction = true;\n        currentFunction = [line];\n        braceCount = (line.match(/\\{/g) || []).length - (line.match(/\\}/g) || []).length;\n      } else if (inFunction) {\n        currentFunction.push(line);\n        braceCount += (line.match(/\\{/g) || []).length - (line.match(/\\}/g) || []).length;\n        \n        if (braceCount === 0) {\n          functions.push(currentFunction.join('\\n'));\n          inFunction = false;\n          currentFunction = [];\n        }\n      } else {\n        body.push(line);\n      }\n    }\n    \n    return {\n      functions,\n      body: body.join('\\n')\n    };\n  }\n}\n\nclass WGSLBuilder {\n  constructor() {\n    this.functions = [];\n    this.bindings = [];\n    this.structs = [];\n  }\n\n  fn(name, params, returnType, body) {\n    const fnCode = `fn ${name}(${params}) -> ${returnType} {\\n${body}\\n}`;\n    this.functions.push(fnCode);\n    return this; // for chaining\n  }\n\n  binding(group, binding, type, name) {\n    this.bindings.push(`@group(${group}) @binding(${binding}) var ${name}: ${type};`);\n    return this;\n  }\n\n  struct(name, body) {\n    this.structs.push(`struct ${name} {\\n${body}\\n}`);\n    return this;\n  }\n\n  get main() {\n    // Return a template literal function\n    return (strings, ...values) => {\n      // Build the complete code\n      let code = '';\n      \n      // Add bindings\n      if (this.bindings.length > 0) {\n        code += this.bindings.join('\\n') + '\\n\\n';\n      }\n      \n      // Add structs\n      if (this.structs.length > 0) {\n        code += this.structs.join('\\n\\n') + '\\n\\n';\n      }\n      \n      // Add functions\n      if (this.functions.length > 0) {\n        code += this.functions.join('\\n\\n') + '\\n\\n';\n      }\n      \n      // Add main body from template literal\n      const mainBody = String.raw({ raw: strings }, ...values);\n      code += mainBody;\n      \n      // Check if main function already exists\n      if (/fn\\s+main\\s*\\(/.test(code)) {\n        return code;\n      }\n      \n      // Use existing parser to separate any remaining functions from body\n      const { functions: parsedFunctions, body } = extractFunctionsAndBody(code);\n      \n      // Build final result\n      let result = '';\n      \n      if (parsedFunctions.length > 0) {\n        result += parsedFunctions.join('\\n\\n') + '\\n\\n';\n      }\n      \n      result += '@compute @workgroup_size(1)\\n';\n      result += 'fn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n';\n      \n      if (body) {\n        const indentedBody = body.split('\\n')\n          .map(line => line.trim() ? '  ' + line : line)\n          .join('\\n');\n        result += indentedBody + '\\n';\n      }\n      \n      result += '}';\n      \n      return result;\n    };\n  }\n}\n\n// Original template literal function\nexport function wgsl(strings, ...values) {\n  let code = String.raw({ raw: strings }, ...values);\n\n  // Replace width and height placeholders\n  code = code.replace(/\\bwidth\\b/g, width.toFixed(2));\n  code = code.replace(/\\bheight\\b/g, height.toFixed(2));\n\n  // If code uses noise or noise2, inject the noise function implementation\n  if (/\\bnoise\\s*\\(|\\bnoise2\\s*\\(|\\bnoise3\\s*\\(/.test(code)) {\n    // Only add if not already present\n    if (!/fn\\s+noise\\s*\\(/.test(code) && !/fn\\s+noise2\\s*\\(/.test(code) && !/fn\\s+noise3\\s*\\(/.test(code)) {\n      code = getNoiseCode() + '\\n\\n' + code;\n    }\n  }\n\n  // Remove leading/trailing whitespace but preserve internal structure\n  code = code.trim();\n  \n  // If user already wrote main function, return as-is\n  if (/fn\\s+main\\s*\\(/.test(code)) {\n    return code;\n  }\n  \n  // Extract helper functions and body\n  const { functions, body } = extractFunctionsAndBody(code);\n  \n  // Build the final WGSL code\n  let result = '';\n  \n  // Add functions first\n  if (functions.length > 0) {\n    result += functions.join('\\n\\n') + '\\n\\n';\n  }\n  \n  // Add main function with body\n  result += '@compute @workgroup_size(1)\\n';\n  result += 'fn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n';\n  \n  if (body) {\n    // Indent the body\n    const indentedBody = body.split('\\n')\n      .map(line => line.trim() ? '  ' + line : line)\n      .join('\\n');\n    result += indentedBody + '\\n';\n  }\n  \n  result += '}';\n  \n  return result;\n}\n\n// Add compute builder to wgsl\nwgsl.compute = () => new WGSLBuilder();\n// Allow setting width for parsing stage\nwgsl.setWidth = (value) => { wgsl.width = value; };","/**\n * WebGPU Utils - A utility library for WebGPU development\n * @module webgpu-utils\n */\n\n\n/**\n * Library version\n * @type {string}\n */\nexport const VERSION = '0.1.0';\n\nexport * from './core.js';\nexport * from './canvas.js';\nexport * from './camera.js';\nexport * from './noise.js';\nexport * from './passes.js';\nexport * from './render_passes.js';\nexport * from './struct.js';\nexport * from './raycasting.js';\nexport * from './utilities.js';\nexport * from './wgsl.js';\n","/**\n * @file WebGPU camera utilities for WGSL shaders\n * Provides camera functions and perspective calculations for 3D rendering\n */\n\nimport { width, height } from './canvas.js';\n\n/**\n * Generates camera-related WGSL code\n * @param {Object} [options] - Camera configuration options\n * @param {number} [options.cameraDistance=250.0] - Base distance of camera from origin\n * @param {number} [options.rotationSpeed=0.01] - Camera rotation speed\n * @param {number} [options.fieldOfView=90.0] - Camera field of view in degrees\n * @param {number} [options.nearPlane=1.0] - Near clipping plane distance\n * @param {number} [options.farPlane=1000.0] - Far clipping plane distance\n * @param {number} [options.cameraY=-100.0] - Camera Y position\n * @returns {string} WGSL camera code\n */\nexport function getCamStuff(options = {}) {\n    const {\n        cameraDistance = 250.0,\n        rotationSpeed = 0.01,\n        fieldOfView = 90.0,\n        nearPlane = 1.0,\n        farPlane = 1000.0,\n        cameraY = -100.0\n    } = options;\n\n    return `\n    // Camera configuration constants\n    const BASE_CAMERA_DISTANCE = ${cameraDistance};\n    const ROTATION_SPEED = ${rotationSpeed};            // Adjust this to change rotation speed\n    const FIELD_OF_VIEW = ${fieldOfView};\n    const ASPECT_RATIO = ${width / height};\n    const NEAR_PLANE = ${nearPlane};\n    const FAR_PLANE = ${farPlane};\n    const CAMERA_UP = vec3 < f32 > (0.0, 1.0, 0.0);\n\n    // Orthographic parameters\n    const ORTHO_SIZE = 5.0;               // Size of the orthographic view (height)\n    const ORTHO_WIDTH = ORTHO_SIZE * ASPECT_RATIO;\n    const ORTHO_HEIGHT = ORTHO_SIZE;\n\n    fn calculateCameraPosition() -> vec3 < f32 > {\n        let angle = globalData[0].frame * ROTATION_SPEED;\n        return vec3 < f32 > (\n            cos(angle) * BASE_CAMERA_DISTANCE,\n            ${cameraY},\n            sin(angle) * BASE_CAMERA_DISTANCE\n        );\n    }\n\n    fn lookAt(eye: vec3 < f32 >, targetDir: vec3 < f32 >, up: vec3 < f32 >) -> mat4x4 < f32 > {\n        let f = normalize(targetDir - eye);\n        let s = normalize(cross(f, up));\n        let u = cross(s, f);\n\n        return mat4x4 < f32 > (\n            vec4 < f32 > (s.x, u.x, -f.x, 0.0),\n            vec4 < f32 > (s.y, u.y, -f.y, 0.0),\n            vec4 < f32 > (s.z, u.z, -f.z, 0.0),\n            vec4 < f32 > (-dot(s, eye), -dot(u, eye), dot(f, eye), 1.0)\n        );\n    }\n\n    fn perspectiveMatrix() -> mat4x4 < f32 > {\n        let fovRad = radians(FIELD_OF_VIEW);\n        let f = 1.0 / tan(fovRad / 2.0);\n\n        return mat4x4 < f32 > (\n            vec4 < f32 > (f / ASPECT_RATIO, 0.0, 0.0, 0.0),\n            vec4 < f32 > (0.0, f, 0.0, 0.0),\n            vec4 < f32 > (0.0, 0.0, (FAR_PLANE + NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), -1.0),\n            vec4 < f32 > (0.0, 0.0, (2.0 * FAR_PLANE * NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), 0.0)\n        );\n    }\n\n    fn worldToScreenPerspective(worldPos: vec3 < f32 >) -> vec2 < f32 > {\n        let cameraPos = calculateCameraPosition();\n        let viewMatrix = lookAt(cameraPos, vec3 < f32 > (0.0, 0.0, 0.0), CAMERA_UP);\n        let projMatrix = perspectiveMatrix();\n        let viewProj = projMatrix * viewMatrix;\n\n        // Transform to clip space\n        let clipPos = viewProj * vec4 < f32 > (worldPos, 1.0);\n\n        // Perspective division\n        let ndcPos = clipPos.xyz / clipPos.w;\n\n        // Convert to screen coordinates [0,1]\n        return vec2 < f32 > (\n            (ndcPos.x + 1.0) * 0.5,\n            (ndcPos.y + 1.0) * 0.5\n        );\n    }\n    `;\n}\n\n/**\n * Creates a static camera at a specific position\n * @param {Object} position - Camera position\n * @param {number} position.x - X coordinate\n * @param {number} position.y - Y coordinate\n * @param {number} position.z - Z coordinate\n * @param {Object} [target] - Camera target position (default: origin)\n * @param {number} [target.x=0] - Target X coordinate\n * @param {number} [target.y=0] - Target Y coordinate\n * @param {number} [target.z=0] - Target Z coordinate\n * @returns {string} WGSL code for a static camera\n */\nexport function createStaticCamera(position, target = { x: 0, y: 0, z: 0 }) {\n    if (!position || typeof position !== 'object' || \n        typeof position.x !== 'number' || \n        typeof position.y !== 'number' || \n        typeof position.z !== 'number') {\n        throw new Error('createStaticCamera: Valid position object with x, y, z coordinates is required');\n    }\n\n    return `\n    // Static camera configuration constants\n    const FIELD_OF_VIEW = 90.0;\n    const ASPECT_RATIO = ${width / height};\n    const NEAR_PLANE = 1.0;\n    const FAR_PLANE = 1000.0;\n    const CAMERA_UP = vec3 < f32 > (0.0, 1.0, 0.0);\n    \n    const CAMERA_POSITION = vec3<f32>(${position.x}, ${position.y}, ${position.z});\n    const CAMERA_TARGET = vec3<f32>(${target.x}, ${target.y}, ${target.z});\n\n    fn calculateCameraPosition() -> vec3 < f32 > {\n        return CAMERA_POSITION;\n    }\n\n    fn lookAt(eye: vec3 < f32 >, targetDir: vec3 < f32 >, up: vec3 < f32 >) -> mat4x4 < f32 > {\n        let f = normalize(targetDir - eye);\n        let s = normalize(cross(f, up));\n        let u = cross(s, f);\n\n        return mat4x4 < f32 > (\n            vec4 < f32 > (s.x, u.x, -f.x, 0.0),\n            vec4 < f32 > (s.y, u.y, -f.y, 0.0),\n            vec4 < f32 > (s.z, u.z, -f.z, 0.0),\n            vec4 < f32 > (-dot(s, eye), -dot(u, eye), dot(f, eye), 1.0)\n        );\n    }\n\n    fn perspectiveMatrix() -> mat4x4 < f32 > {\n        let fovRad = radians(FIELD_OF_VIEW);\n        let f = 1.0 / tan(fovRad / 2.0);\n\n        return mat4x4 < f32 > (\n            vec4 < f32 > (f / ASPECT_RATIO, 0.0, 0.0, 0.0),\n            vec4 < f32 > (0.0, f, 0.0, 0.0),\n            vec4 < f32 > (0.0, 0.0, (FAR_PLANE + NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), -1.0),\n            vec4 < f32 > (0.0, 0.0, (2.0 * FAR_PLANE * NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), 0.0)\n        );\n    }\n\n    fn worldToScreenPerspective(worldPos: vec3 < f32 >) -> vec2 < f32 > {\n        let cameraPos = calculateCameraPosition();\n        let viewMatrix = lookAt(cameraPos, CAMERA_TARGET, CAMERA_UP);\n        let projMatrix = perspectiveMatrix();\n        let viewProj = projMatrix * viewMatrix;\n\n        // Transform to clip space\n        let clipPos = viewProj * vec4 < f32 > (worldPos, 1.0);\n\n        // Perspective division\n        let ndcPos = clipPos.xyz / clipPos.w;\n\n        // Convert to screen coordinates [0,1]\n        return vec2 < f32 > (\n            (ndcPos.x + 1.0) * 0.5,\n            (ndcPos.y + 1.0) * 0.5\n        );\n    }\n    `;\n}\n\n/**\n * Creates a first-person camera controller WGSL code\n * @param {Object} [options] - First-person camera options\n * @param {Object} [options.initialPosition={ x: 0, y: 2, z: 5 }] - Starting position\n * @param {Object} [options.initialLookAt={ x: 0, y: 0, z: 0 }] - Initial look target\n * @param {number} [options.moveSpeed=0.1] - Camera movement speed\n * @param {number} [options.sensitivity=0.003] - Mouse look sensitivity\n * @returns {string} WGSL first-person camera code\n */\nexport function createFirstPersonCamera(options = {}) {\n    const {\n        initialPosition = { x: 0, y: 2, z: 5 },\n        initialLookAt = { x: 0, y: 0, z: 0 },\n        moveSpeed = 0.1,\n        sensitivity = 0.003\n    } = options;\n    \n    return `\n    // First-person camera constants\n    const CAMERA_MOVE_SPEED = ${moveSpeed};\n    const MOUSE_SENSITIVITY = ${sensitivity};\n    const FIELD_OF_VIEW = 70.0;\n    const ASPECT_RATIO = ${width / height};\n    const NEAR_PLANE = 0.1;\n    const FAR_PLANE = 1000.0;\n    const CAMERA_UP = vec3<f32>(0.0, 1.0, 0.0);\n    \n    // Camera state (should be fed from uniform buffer in real implementation)\n    var<private> camera_position = vec3<f32>(${initialPosition.x}, ${initialPosition.y}, ${initialPosition.z});\n    var<private> camera_front = normalize(vec3<f32>(${initialLookAt.x - initialPosition.x}, \n                                                   ${initialLookAt.y - initialPosition.y},\n                                                   ${initialLookAt.z - initialPosition.z}));\n    var<private> camera_right = normalize(cross(camera_front, CAMERA_UP));\n    var<private> camera_up = normalize(cross(camera_right, camera_front));\n    var<private> yaw = -90.0; // Default is looking along negative z\n    var<private> pitch = 0.0;\n    \n    fn updateCameraVectors() {\n        let direction = vec3<f32>(\n            cos(radians(yaw)) * cos(radians(pitch)),\n            sin(radians(pitch)),\n            sin(radians(yaw)) * cos(radians(pitch))\n        );\n        \n        camera_front = normalize(direction);\n        camera_right = normalize(cross(camera_front, CAMERA_UP));\n        camera_up = normalize(cross(camera_right, camera_front));\n    }\n    \n    fn moveCamera(direction: i32) {\n        switch direction {\n            case 0: { // Forward\n                camera_position += CAMERA_MOVE_SPEED * camera_front;\n            }\n            case 1: { // Backward\n                camera_position -= CAMERA_MOVE_SPEED * camera_front;\n            }\n            case 2: { // Left\n                camera_position -= CAMERA_MOVE_SPEED * camera_right;\n            }\n            case 3: { // Right\n                camera_position += CAMERA_MOVE_SPEED * camera_right;\n            }\n            case 4: { // Up\n                camera_position += CAMERA_MOVE_SPEED * CAMERA_UP;\n            }\n            case 5: { // Down\n                camera_position -= CAMERA_MOVE_SPEED * CAMERA_UP;\n            }\n            default: {}\n        }\n    }\n    \n    fn rotateCamera(xoffset: f32, yoffset: f32) {\n        yaw += xoffset * MOUSE_SENSITIVITY;\n        pitch += yoffset * MOUSE_SENSITIVITY;\n        \n        // Constrain pitch\n        pitch = clamp(pitch, -89.0, 89.0);\n        \n        updateCameraVectors();\n    }\n    \n    fn getViewMatrix() -> mat4x4<f32> {\n        let target = camera_position + camera_front;\n        return lookAt(camera_position, target, camera_up);\n    }\n    \n    fn lookAt(eye: vec3<f32>, target: vec3<f32>, up: vec3<f32>) -> mat4x4<f32> {\n        let f = normalize(target - eye);\n        let r = normalize(cross(f, up));\n        let u = cross(r, f);\n        \n        return mat4x4<f32>(\n            vec4<f32>(r.x, u.x, -f.x, 0.0),\n            vec4<f32>(r.y, u.y, -f.y, 0.0),\n            vec4<f32>(r.z, u.z, -f.z, 0.0),\n            vec4<f32>(-dot(r, eye), -dot(u, eye), dot(f, eye), 1.0)\n        );\n    }\n    \n    fn perspectiveMatrix() -> mat4x4<f32> {\n        let fovRad = radians(FIELD_OF_VIEW);\n        let f = 1.0 / tan(fovRad / 2.0);\n        \n        return mat4x4<f32>(\n            vec4<f32>(f / ASPECT_RATIO, 0.0, 0.0, 0.0),\n            vec4<f32>(0.0, f, 0.0, 0.0),\n            vec4<f32>(0.0, 0.0, (FAR_PLANE + NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), -1.0),\n            vec4<f32>(0.0, 0.0, (2.0 * FAR_PLANE * NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), 0.0)\n        );\n    }\n    \n    fn worldToScreenPerspective(worldPos: vec3<f32>) -> vec2<f32> {\n        let viewMatrix = getViewMatrix();\n        let projMatrix = perspectiveMatrix();\n        let viewProj = projMatrix * viewMatrix;\n        \n        // Transform to clip space\n        let clipPos = viewProj * vec4<f32>(worldPos, 1.0);\n        \n        // Perspective division\n        let ndcPos = clipPos.xyz / clipPos.w;\n        \n        // Convert to screen coordinates [0,1]\n        return vec2<f32>(\n            (ndcPos.x + 1.0) * 0.5,\n            (ndcPos.y + 1.0) * 0.5\n        );\n    }\n    `;\n}\n\nexport default {\n    getCamStuff,\n    createStaticCamera,\n    createFirstPersonCamera\n};\n"],"names":["getNoiseCode","noiseBuffer","Buffer","Math","random","wgslNoise","wgslNoise2","exports","Struct","constructor","name","data","trim","Error","this","floatSize","fillerCount","i","push","type","type_f32","add","byteSize","reduce","acc","cur","size","code","str","forEach","slice","object","obj","toFloat32Array","vals","Array","arr","Float32Array","length","offset","val","value","undefined","set","fromFloat32Array","createBuffer","isArray","newBuffer","struct","error","message","buffers","nextData","nextBuffer","count","type_vec2","x","y","type_vec3","z","type_vec4","w","type_color","r","g","b","a","createMouseBuffer","canvas","mouseStruct","mouseBuffer","mouseEvent","e","rect","getBoundingClientRect","mouseIsDown","buttons","update","width","clientX","left","height","clientY","top","document","addEventListener","createTimeBuffer","timeBuffer","setInterval","performance","now","RenderPass","texture","device","module","createShaderModule","pipeline","createRenderPipeline","layout","vertex","entryPoint","fragment","targets","format","canvasPresentationFormat","sampler","createSampler","magFilter","minFilter","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","renderPassDescriptor","colorAttachments","clearValue","loadOp","storeOp","run","encoder","view","ctx","getCurrentTexture","createView","pass","beginRenderPass","setPipeline","setBindGroup","draw","end","ComputePass","bindings","dispatchSize","regex","renderTxtr","function","feedbackTxtr","auto","match","some","newBinding","test","multipleBuffer","find","multipleBufferIndex","findIndex","map","buffer","newBindings","bindingsCode","getBindingCode","createComputePipeline","compute","bind","beginComputePass","dispatchWorkgroups","runPasses","passes","repeats","commandEncoder","createCommandEncoder","p","queue","submit","finish","renderParams","bgColor","async","createRenderPass","options","createTextures","createClearPass","renderPass","basicRenderCode","Texture","write","matchPass","clearPass","createMatchPass","read","initCanvas","navigator","gpu","webgpu_notSupported","adapter","requestAdapter","requestDevice","event","console","querySelector","createElement","container","containerId","getElementById","appendChild","clientWidth","clientHeight","style","display","body","window","innerWidth","innerHeight","getContext","getPreferredCanvasFormat","configure","alphaMode","key","href","toDataURL","download","Date","toISOString","replace","click","domReady","Promise","resolve","readyState","element","innerText","warn","byteLength","label","usage","GPUBufferUsage","STORAGE","COPY_DST","COPY_SRC","mappedAtCreation","getMappedRange","unmap","writeBuffer","index","bufferType","getData","readBuffer","MAP_READ","copyBufferToBuffer","commands","mapAsync","GPUMapMode","READ","copyArrayBuffer","newdata","createTexture","GPUTextureUsage","STORAGE_BINDING","TEXTURE_BINDING","TextureBindingHelper","readOrWrite","bindingIndex","cameraCode","WGSLParser","position","functions","peek","advance","skipWhitespace","skipComment","skipWhitespaceAndComments","skipped","before","readIdentifier","result","matchKeyword","keyword","start","findMatchingBrace","braceCount","parseFunction","parenCount","angleCount","bodyEnd","parse","fnCode","lineStart","line","join","extractFunctionsAndBody","lines","split","filter","inFunction","currentFunction","startsWith","WGSLBuilder","structs","fn","params","returnType","group","main","strings","values","String","raw","parsedFunctions","wgsl","toFixed","setWidth","floor","initialPosition","initialLookAt","moveSpeed","sensitivity","customCameraCode","globalThis","target","cameraDistance","rotationSpeed","fieldOfView","nearPlane","farPlane","cameraY","mouse","time","feedback","inMin","inMax","outMin","outMax","color","v","max","min","ms","setTimeout"],"mappings":"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"}