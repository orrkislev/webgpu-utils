{"version":3,"file":"webgpu-utils.min.js","sources":["../src/struct.js","../src/utilities.js","../src/passes.js","../src/render_passes.js","../src/canvas.js","../src/core.js","../src/noise.js","../src/raycasting.js","../src/wgsl.js","../src/index.js","../src/camera.js"],"sourcesContent":["import { Buffer } from './core.js';\n\n/**\n * A WebGPU compatible data structure for defining structured buffers\n */\nexport class Struct {\n  /**\n   * Create a new Struct\n   * @param {string} name - The name of the struct in shader code\n   * @param {Array} [data=[]] - Initial data array of {name, type} objects\n   */\n  constructor(name, data = []) {\n    if (typeof name !== 'string' || name.trim() === '') {\n      throw new Error('Struct: Name must be a non-empty string');\n    }\n\n    this.name = name;\n    this.data = data;\n\n    // Add padding if needed to align to vec4 (16 bytes)\n    if (this.floatSize % 4 != 0) {\n      const fillerCount = 4 - (this.floatSize % 4);\n      for (let i = 0; i < fillerCount; i++) {\n        this.data.push({ name: `FILLER___${i}`, type: type_f32 });\n      }\n    }\n  }\n\n  /**\n   * Add a field to the struct\n   * @param {string} name - Field name\n   * @param {Object} type - Field type (one of the predefined types e.g. type_f32, type_vec2)\n   */\n  add(name, type) {\n    if (typeof name !== 'string' || name.trim() === '') {\n      throw new Error('Struct.add: Field name must be a non-empty string');\n    }\n    if (!type || typeof type !== 'object' || !('size' in type)) {\n      throw new Error('Struct.add: Invalid type provided');\n    }\n\n    this.data.push({ name, type });\n  }\n\n  /**\n   * Get the size of the struct in bytes\n   * @returns {number} Size in bytes\n   */\n  get byteSize() {\n    return this.data.reduce((acc, cur) => acc + cur.type.size, 0);\n  }\n\n  /**\n   * Get the size of the struct in float units (4 bytes each)\n   * @returns {number} Size in float units\n   */\n  get floatSize() {\n    return this.byteSize / 4;\n  }\n\n  /**\n   * Get the WGSL code representation of this struct\n   * @returns {string} WGSL struct declaration\n   */\n  get code() {\n    let str = 'struct ' + this.name + ' {\\n';\n    this.data.forEach(({ name, type }) => {\n      str += type.code(name) + ',\\n';\n    });\n    str = str.slice(0, -2); // Remove last comma and newline\n    return str + '\\n};';\n  }\n\n  /**\n   * Create a JavaScript object matching this struct with default values\n   * @returns {Object} Default object instance\n   */\n  object() {\n    const obj = {};\n    this.data.forEach(({ name, type }) => {\n      obj[name] = type.object();\n    });\n    return obj;\n  }\n\n  /**\n   * Convert JavaScript objects to Float32Array for GPU upload\n   * @param {Object|Array} vals - Object(s) to convert\n   * @returns {Float32Array} Packed Float32Array ready for GPU upload\n   * @throws {Error} If input is invalid\n   */\n  toFloat32Array(vals) {\n    if (!vals) {\n      throw new Error('Struct.toFloat32Array: Input values are required');\n    }\n\n    if (!(vals instanceof Array)) vals = [vals];\n    const arr = new Float32Array(this.floatSize * vals.length);\n    let offset = 0;\n\n    vals.forEach((val, i) => {\n      if (!val || typeof val !== 'object') {\n        throw new Error(`Struct.toFloat32Array: Invalid value at index ${i}`);\n      }\n\n      this.data.forEach(({ name, type }) => {\n        const value = val[name];\n        if (value === undefined) {\n          throw new Error(`Struct.toFloat32Array: Missing field ${name} at index ${i}`);\n        }\n\n        if (type instanceof Struct) {\n          arr.set(type.toFloat32Array(value), offset);\n        } else {\n          arr.set(type.toFloat32Array(value), offset);\n        }\n        offset += type.size / 4;\n      });\n    });\n\n    return arr;\n  }\n\n  /**\n   * Convert a Float32Array back to JavaScript objects\n   * @param {Float32Array} arr - Array to convert\n   * @returns {Array} Array of JavaScript objects\n   * @throws {Error} If the input is not a Float32Array\n   */\n  fromFloat32Array(arr) {\n    if (!(arr instanceof Float32Array)) {\n      throw new Error('Struct.fromFloat32Array: Input must be a Float32Array');\n    }\n\n    const vals = [];\n    let offset = 0;\n\n    while (offset < arr.length) {\n      const val = {};\n      this.data.forEach(({ name, type }) => {\n        if (offset + type.size / 4 > arr.length) {\n          throw new Error('Struct.fromFloat32Array: Array too short for struct layout');\n        }\n\n        if (type instanceof Struct) {\n          val[name] = type.fromFloat32Array(arr.slice(offset, offset + type.size / 4));\n        } else {\n          val[name] = type.fromFloat32Array(arr.slice(offset, offset + type.size / 4));\n        }\n        offset += type.size / 4;\n      });\n      vals.push(val);\n    }\n\n    return vals;\n  }\n\n  /**\n   * Create a WebGPU buffer from JavaScript objects\n   * @param {Array|Object} vals - Values to store in the buffer\n   * @param {string} name - Buffer name\n   * @returns {Buffer|Array<Buffer>} Buffer or array of buffers if data exceeds size limit\n   * @throws {Error} If input is invalid\n   */\n  createBuffer(name, vals) {\n    if (!vals) {\n      throw new Error('Struct.createBuffer: Values are required');\n    }\n\n    if (!Array.isArray(vals)) {\n      const newBuffer = new Buffer(name, this.toFloat32Array([vals]));\n      newBuffer.struct = this;\n      return newBuffer;\n    }\n\n    if (vals.length < 1) {\n      throw new Error('Struct.createBuffer: Empty values array');\n    }\n\n    if (vals.length < 65000) {\n      try {\n        const newBuffer = new Buffer(name, this.toFloat32Array(vals));\n        newBuffer.struct = this;\n        newBuffer.isArray = true\n        return newBuffer;\n      } catch (error) {\n        throw new Error(`Struct.createBuffer: Failed to create buffer: ${error.message}`);\n      }\n    }\n\n    // Split into multiple buffers if too large\n    const buffers = [];\n    for (let i = 0; i < vals.length; i += 65000) {\n      const nextData = vals.slice(i, i + 65000);\n      try {\n        const nextBuffer = new Buffer(name, this.toFloat32Array(nextData));\n        nextBuffer.count = nextData.length;\n        nextBuffer.struct = this;\n        nextBuffer.isArray = true;\n        buffers.push(nextBuffer);\n      } catch (error) {\n        throw new Error(`Struct.createBuffer: Failed to create buffer chunk ${i}: ${error.message}`);\n      }\n    }\n    return buffers;\n  }\n}\n\n/**\n * Float (f32) type definition for WGSL\n */\nexport const type_f32 = {\n  size: 4,\n  toFloat32Array: (val) => {\n    if (typeof val !== 'number') {\n      throw new Error('type_f32.toFloat32Array: Expected a number');\n    }\n    return new Float32Array([val]);\n  },\n  fromFloat32Array: (arr) => arr[0],\n  code: (name) => `${name}: f32`,\n  object: () => 0\n};\n\n/**\n * 2D vector (vec2<f32>) type definition for WGSL\n */\nexport const type_vec2 = {\n  size: 8,\n  toFloat32Array: (val) => {\n    if (!val || typeof val !== 'object' || !('x' in val) || !('y' in val)) {\n      throw new Error('type_vec2.toFloat32Array: Expected an object with x and y properties');\n    }\n    return new Float32Array([val.x, val.y]);\n  },\n  fromFloat32Array: (arr) => ({ x: arr[0], y: arr[1] }),\n  code: (name) => `${name}: vec2<f32>`,\n  object: () => ({ x: 0, y: 0 })\n};\n\n/**\n * 3D vector (vec3<f32>) type definition for WGSL\n */\nexport const type_vec3 = {\n  size: 12,\n  toFloat32Array: (val) => {\n    if (!val || typeof val !== 'object' || !('x' in val) || !('y' in val) || !('z' in val)) {\n      throw new Error('type_vec3.toFloat32Array: Expected an object with x, y, and z properties');\n    }\n    return new Float32Array([val.x, val.y, val.z]);\n  },\n  fromFloat32Array: (arr) => ({ x: arr[0], y: arr[1], z: arr[2] }),\n  code: (name) => `${name}: vec3<f32>`,\n  object: () => ({ x: 0, y: 0, z: 0 })\n};\n\n/**\n * 4D vector (vec4<f32>) type definition for WGSL\n */\nexport const type_vec4 = {\n  size: 16,\n  toFloat32Array: (val) => {\n    if (!val || typeof val !== 'object' || !('x' in val) || !('y' in val) || !('z' in val) || !('w' in val)) {\n      throw new Error('type_vec4.toFloat32Array: Expected an object with x, y, z, and w properties');\n    }\n    return new Float32Array([val.x, val.y, val.z, val.w]);\n  },\n  fromFloat32Array: (arr) => ({ x: arr[0], y: arr[1], z: arr[2], w: arr[3] }),\n  code: (name) => `${name}: vec4<f32>`,\n  object: () => ({ x: 0, y: 0, z: 0, w: 0 })\n};\n\n/**\n * RGBA color (vec4<f32>) type definition for WGSL\n * Used for color values with r,g,b,a components\n */\nexport const type_color = {\n  size: 16,\n  toFloat32Array: (val) => {\n    if (!val || typeof val !== 'object' || !('r' in val) || !('g' in val) || !('b' in val) || !('a' in val)) {\n      throw new Error('type_color.toFloat32Array: Expected an object with r, g, b, and a properties');\n    }\n    return new Float32Array([val.r, val.g, val.b, val.a]);\n  },\n  fromFloat32Array: (arr) => ({ r: arr[0], g: arr[1], b: arr[2], a: arr[3] }),\n  code: (name) => `${name}: vec4<f32>`,\n  object: () => ({ r: 0, g: 0, b: 0, a: 1 })\n};\n","import { Buffer } from './core.js';\nimport { Struct, type_f32, type_vec2 } from './struct.js';\nimport { canvas, height, width } from './canvas.js';\n\n/**\n * Generates a random number between two values\n * @param {number} [a=1] - Upper bound (if only one argument is provided) or range\n * @param {number} [b=0] - Lower bound\n * @returns {number} Random number between a and b\n */\nexport const random = (a = 1, b = 0) => Math.random() * (a - b) + b;\n\n/**\n * Selects a random element from an array\n * @param {Array} arr - The array to select from\n * @returns {*} Random element from the array\n * @throws {Error} If the array is empty or not an array\n */\nexport const choose = (arr) => {\n    if (!Array.isArray(arr)) {\n        throw new Error('choose: Expected an array as argument');\n    }\n    if (arr.length === 0) {\n        throw new Error('choose: Cannot select from an empty array');\n    }\n    return arr[Math.floor(random(arr.length))];\n};\n\n/**\n * Creates a promise that resolves after a specified time\n * @param {number} [ms=10] - Milliseconds to wait\n * @returns {Promise} Promise that resolves after the specified time\n */\nexport const timeout = async (ms = 10) => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Maps a value from one range to another\n * @param {number} val - The value to map\n * @param {number} inMin - Input range minimum\n * @param {number} inMax - Input range maximum\n * @param {number} outMin - Output range minimum\n * @param {number} outMax - Output range maximum\n * @returns {number} Mapped value\n */\nexport const map = (val, inMin, inMax, outMin, outMax) =>\n    outMin + (outMax - outMin) * (val - inMin) / (inMax - inMin);\n\n\n/**\n * Creates a mouse position buffer that updates on mouse movement\n * @returns {Buffer} Mouse position buffer with x, y coordinates and button state\n * @throws {Error} If canvas is not defined\n * @example\n * createMouseBuffer();\n * // This will create a buffer that updates with the mouse position and button state\n * @throws {Error} If canvas is not defined\n */\nexport let mouseBuffer = null;\nexport function createMouseBuffer() {\n    if (!canvas) {\n        throw new Error('createMouseBuffer: Canvas is not defined');\n    }\n    const mouseStruct = new Struct('mouseStruct', [\n        { name: 'pos', type: type_vec2 },\n        { name: 'button', type: type_f32 }\n    ])\n    mouseBuffer = mouseStruct.createBuffer('mouse', mouseStruct.object())\n    const mouseEvent = (e) => {\n        const rect = canvas.getBoundingClientRect()\n        const mouseIsDown = e.buttons == 1 ? 0 : 1\n        // mouseBuffer.update(mouseStruct.toFloat32Array([newMouseData]))\n        mouseBuffer.update(new Float32Array([\n            width * (e.clientX - rect.left) / rect.width,\n            height * (e.clientY - rect.top) / rect.height,\n            mouseIsDown\n        ]))\n    }\n    document.addEventListener('mousemove', mouseEvent)\n    document.addEventListener('mousedown', mouseEvent)\n    document.addEventListener('mouseup', mouseEvent)\n}\n\n\n/** * Creates a time buffer that updates with the current time in seconds\n * @returns {Buffer} Time buffer that updates with the current time\n * @example\n * createTimeBuffer();\n * // This will create a buffer that updates with the current time in seconds\n */\nexport let timeBuffer = null;\nexport function getTimeBuffer() {\n    if (!timeBuffer) {\n        throw new Error('getTimeBuffer: Time buffer has not been created yet');\n    }\n    return timeBuffer;\n}\nexport function createTimeBuffer() {\n    timeBuffer = new Buffer('time', new Float32Array([0]))\n    setInterval(() => {\n        timeBuffer.update(new Float32Array([performance.now() / 1000]))\n    }, 1000 / 60) // Update at 60 FPS\n    return timeBuffer\n}","// RenderPass and ComputePass classes extracted from render.js\n\nimport { device, ctx, canvasPresentationFormat, width, height } from './canvas.js';\nimport { renderTxtr, feedbackTxtr } from './render_passes.js';\nimport { mouseBuffer, timeBuffer } from './utilities.js';\n\nexport class RenderPass {\n    constructor(texture, code) {\n        if (!device) {\n            throw new Error('RenderPass: WebGPU device not initialized. Call initCanvas() first.');\n        }\n        if (!texture || typeof texture !== 'object') {\n            throw new Error('RenderPass: Invalid texture');\n        }\n        if (typeof code !== 'string' || code.trim() === '') {\n            throw new Error('RenderPass: Shader code must be a non-empty string');\n        }\n        try {\n            this.module = device.createShaderModule({ code });\n            this.pipeline = device.createRenderPipeline({\n                layout: 'auto',\n                vertex: { module: this.module, entryPoint: 'vs' },\n                fragment: { module: this.module, entryPoint: 'fs', targets: [{ format: canvasPresentationFormat }] },\n            });\n            this.sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });\n            this.bindGroup = device.createBindGroup({\n                layout: this.pipeline.getBindGroupLayout(0),\n                entries: [\n                    { binding: 0, resource: this.sampler },\n                    { binding: 1, resource: texture.resource },\n                ],\n            });\n            this.renderPassDescriptor = {\n                colorAttachments: [{ clearValue: [0, 0, 0, 1], loadOp: 'clear', storeOp: 'store' }],\n            };\n        } catch (error) {\n            throw new Error(`Failed to create RenderPass: ${error.message}`);\n        }\n    }\n    run(encoder) {\n        try {\n            this.renderPassDescriptor.colorAttachments[0].view = ctx.getCurrentTexture().createView();\n            const pass = encoder.beginRenderPass(this.renderPassDescriptor);\n            pass.setPipeline(this.pipeline);\n            pass.setBindGroup(0, this.bindGroup);\n            pass.draw(6);\n            pass.end();\n        } catch (error) {\n            throw new Error(`Failed to run RenderPass: ${error.message}`);\n        }\n    }\n}\n\n\nexport class ComputePass {\n    constructor(code, bindings, dispatchSize, entryPoint = 'main') {\n\n        // inject auto-bindings\n        const Auto_Bindings = [\n            { binding: mouseBuffer, regex: /\\bmouse(\\.(pos|button))?\\b/ },\n            { binding: timeBuffer, regex: /\\btime\\b/ },\n            { binding: renderTxtr, regex: /\\brenderTxtr\\b/, function: 'write' },\n            { binding: feedbackTxtr, regex: /\\bfeedbackTxtr\\b/, function: 'read' },\n        ];\n        Auto_Bindings.forEach(auto => {\n            if (code.match(auto.regex)) {\n                if (!bindings.some(b => b.name === auto.binding.name)) {\n                    const newBinding = auto.function ? auto.binding[auto.function]() : auto.binding;\n                    bindings.push(newBinding);\n                }\n            }\n        });\n\n\n        if (bindings.some(b => Array.isArray(b))) {\n            const multipleBuffer = bindings.find(b => Array.isArray(b))\n            const multipleBufferIndex = bindings.findIndex(b => Array.isArray(b))\n            return multipleBuffer.map((buffer, i) => {\n                const newBindings = bindings.slice()\n                newBindings[multipleBufferIndex] = buffer\n                return new ComputePass(code, newBindings, buffer.count, entryPoint)\n            })\n        }\n\n        let bindingsCode = ''\n        bindings.forEach((binding, i) => {\n            bindingsCode += binding.getBindingCode(i) + '\\n';\n        })\n        code = bindingsCode + code;\n\n        bindings.forEach(binding => {\n            if (binding.struct) code = binding.struct.code + '\\n' + code;\n        })\n\n        this.code = code\n\n        this.module = device.createShaderModule({ code });\n        this.pipeline = device.createComputePipeline({\n            layout: 'auto',\n            compute: { module: this.module, entryPoint },\n        });\n        this.bindGroup = device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(0),\n            entries: bindings.map((bind, i) => ({ binding: i, resource: bind.resource })),\n        });\n\n        this.dispatchSize = dispatchSize;\n        if (!Array.isArray(dispatchSize)) this.dispatchSize = [dispatchSize];\n    }\n\n    run(encoder) {\n        const pass = encoder.beginComputePass();\n        pass.setPipeline(this.pipeline);\n        pass.setBindGroup(0, this.bindGroup);\n        pass.dispatchWorkgroups(...this.dispatchSize);\n        pass.end();\n    }\n\n\n\n    /**\n     * Static methods\n     */\n    static texture(code, bindings){\n        return new ComputePass(code, bindings, [width, height]);\n    }\n    static compute(code, bindings, arr){\n        return new ComputePass(code, bindings, [arr.length]);\n    }\n}\n\n/**\n * Execute multiple render or compute passes\n * @param {Array} passes - Array of RenderPass or ComputePass objects (or arrays of passes)\n * @param {number} [repeats=1] - Number of times to repeat the passes\n * @throws {Error} If device is not initialized or passes are invalid\n */\nexport function runPasses(passes, repeats = 1) {\n    if (!device) {\n        throw new Error('runPasses: WebGPU device not initialized. Call initCanvas() first.');\n    }\n\n    if (!Array.isArray(passes))\n        passes = [passes];\n\n    try {\n        const commandEncoder = device.createCommandEncoder();\n        for (let i = 0; i < repeats; i++) {\n            for (const pass of passes) {\n                if (Array.isArray(pass)) {\n                    pass.forEach(p => {\n                        if (!p || typeof p.run !== 'function') {\n                            throw new Error('Invalid pass object in array');\n                        }\n                        p.run(commandEncoder);\n                    });\n                } else {\n                    if (!pass || typeof pass.run !== 'function') {\n                        throw new Error('Invalid pass object');\n                    }\n                    pass.run(commandEncoder);\n                }\n            }\n        }\n        device.queue.submit([commandEncoder.finish()]);\n    } catch (error) {\n        throw new Error(`Failed to run passes: ${error.message}`);\n    }\n}","/**\n * @file WebGPU render passes for common operations\n * Provides specialized render passes for common rendering tasks\n */\n\nimport { RenderPass, ComputePass, runPasses } from './passes.js';\nimport { Texture } from './core.js';\nimport { width, height } from './canvas.js';\n\n/**\n * Global rendering parameters\n * @type {Object}\n */\nconst renderParams = {\n    bgColor: [0, 0, 0]\n};\n\n/**\n * Texture array for render targets\n * @type {Array}\n */\nexport let renderTxtr, feedbackTxtr\nexport let renderPass, matchPass, clearPass;\n\n/**\n * Creates a standard render pass for displaying to screen\n * @async\n * @param {Object} [options] - Render pass options\n * @param {Array<number>} [options.bgColor] - Background color [r, g, b] (0-255)\n * @returns {Promise<RenderPass>} The configured render pass\n */\nexport async function createRenderPass(options = {}) {\n    if (options.bgColor) {\n        renderParams.bgColor = options.bgColor;\n    }\n\n    await createTextures();\n\n    createClearPass()\n\n    renderPass = new RenderPass(renderTxtr, basicRenderCode);\n    return renderPass;\n}\n\n/**\n * Creates textures for rendering\n * @async\n * @returns {Promise<void>}\n */\nexport async function createTextures() {\n    try {\n        renderTxtr = new Texture('renderTxtr', width, height);\n        feedbackTxtr = new Texture('feedbackTxtr', width, height);\n\n        const code = `\n        @compute @workgroup_size(1)\n        fn main(@builtin(global_invocation_id) id: vec3<u32>) {\n          let x: i32 = i32(id.x);\n          let y: i32 = i32(id.y);\n          let clr = vec4f(${renderParams.bgColor[0] / 255},${renderParams.bgColor[1] / 255},${renderParams.bgColor[2] / 255},1.0);\n          textureStore(renderTxtr, vec2<i32>(x, y), clr);\n          textureStore(feedbackTxtr, vec2<i32>(x, y), clr);\n        }`;\n\n        const pass1 = new ComputePass(code, [renderTxtr.write(), feedbackTxtr.write()], [width, height]);\n        runPasses([pass1]);\n    } catch (error) {\n        throw new Error(`Failed to create textures: ${error.message}`);\n    }\n}\n\n/**\n * Basic render code for fullscreen quad rendering\n * @type {string}\n */\nexport const basicRenderCode = `\n    struct OurVertexShaderOutput {\n        @builtin(position) position: vec4f,\n        @location(0) uv: vec2f,\n    };\n\n    @vertex fn vs(@builtin(vertex_index) vertexIndex: u32) -> OurVertexShaderOutput {\n        let pos = array(\n            vec2f(-1.0, -1.0), vec2f(1.0, -1.0),\n            vec2f(-1.0, 1.0), vec2f(-1.0, 1.0),\n            vec2f(1.0, -1.0), vec2f(1.0, 1.0),\n        );\n\n        var vsOutput: OurVertexShaderOutput;\n        let xy = pos[vertexIndex];\n        vsOutput.position = vec4f(xy, 0.0, 1.0);\n        vsOutput.uv = vec2f((xy.x + 1.0) / 2.0, 1.0-(xy.y + 1.0) / 2.0);\n        return vsOutput;\n    }\n\n    @group(0) @binding(0) var ourSampler: sampler;\n    @group(0) @binding(1) var ourTexture: texture_2d<f32>;\n\n    @fragment fn fs(fsInput: OurVertexShaderOutput) -> @location(0) vec4f {\n        return textureSample(ourTexture, ourSampler, fsInput.uv);\n    }\n    `;\n\n/**\n * Creates a pass that matches/copies one texture to another\n * @async\n * @returns {Promise<ComputePass>} The configured compute pass\n */\nexport async function createMatchPass() {\n    if (!renderTxtr || !feedbackTxtr) {\n        throw new Error('createMatchPass: Textures must be created first with createTextures()');\n    }\n\n    const code = `\n    @compute @workgroup_size(1)\n    fn main(@builtin(global_invocation_id) id: vec3<u32>) {\n      let x: i32 = i32(id.x);\n      let y: i32 = i32(id.y);\n      let clr = textureLoad(renderTxtr, vec2<i32>(x, y), 0);\n      textureStore(feedbackTxtr, vec2<i32>(x, y), vec4<f32>(clr.r, clr.g, clr.b, 1.0));\n    }`;\n\n    matchPass = new ComputePass(code, [renderTxtr.read(), feedbackTxtr.write()], [width, height]);\n    return matchPass;\n}\n\n/**\n * Creates a pass that clears all textures to the background color\n * @async\n * @returns {Promise<ComputePass>} The configured compute pass\n */\nexport async function createClearPass() {\n    if (!renderTxtr || !feedbackTxtr) {\n        throw new Error('createClearPass: Textures must be created first with createTextures()');\n    }\n\n    const code = `\n    @compute @workgroup_size(1)\n    fn main(@builtin(global_invocation_id) id: vec3<u32>) {\n      let x: i32 = i32(id.x);\n      let y: i32 = i32(id.y);\n\n      var clr = vec4<f32>(${renderParams.bgColor[0] / 255}, ${renderParams.bgColor[1] / 255}, ${renderParams.bgColor[2] / 255}, 1.0);\n\n      textureStore(renderTxtr, vec2<i32>(x, y), clr);\n      textureStore(feedbackTxtr, vec2<i32>(x, y), clr);\n    }`;\n\n    clearPass = new ComputePass(code, [renderTxtr.write(), feedbackTxtr.write()], [width, height]);\n    return clearPass;\n}\n\n/**\n * Set background color and update render parameters\n * @param {Array<number>} color - RGB color values [0-255]\n */\nexport function setBackgroundColor(color) {\n    if (!Array.isArray(color) || color.length < 3) {\n        throw new Error('setBackgroundColor: Expected an array of at least 3 RGB values [0-255]');\n    }\n\n    renderParams.bgColor = color.map(v => Math.max(0, Math.min(255, v)));\n}\n\nexport default {\n    renderParams,\n    createRenderPass,\n    createTextures,\n    basicRenderCode,\n    createMatchPass,\n    createClearPass,\n    setBackgroundColor\n};\n","/**\n * @file WebGPU canvas initialization and rendering utilities\n * Provides functions to initialize a WebGPU canvas, set up the rendering context,\n * and handle basic rendering operations.\n */\n\nimport { createMatchPass, createRenderPass } from \"./render_passes\";\nimport { createMouseBuffer, createTimeBuffer } from \"./utilities\";\n\nexport let width, height, device;\nexport let canvas, canvasPresentationFormat, ctx;\n\n/**\n * Initialize the WebGPU canvas and device\n * @param {Object} [options] - Canvas initialization options\n * @param {number} [options.width] - Canvas width (defaults to window width * 2)\n * @param {number} [options.height] - Canvas height (defaults to window height * 2)\n * @param {HTMLCanvasElement} [options.canvas] - Existing canvas to use (creates one if not provided)\n * @param {string} [options.containerId] - ID of the container to append the canvas to and size it to\n * @returns {Promise<{device: GPUDevice, canvas: HTMLCanvasElement, width: number, height: number}>}\n * @throws {Error} If WebGPU is not supported or initialization fails\n */\nexport async function initCanvas(options = {}) {\n    if (!navigator.gpu) {\n        throw new Error('WebGPU not supported in this browser.');\n    }\n\n    try {\n        const adapter = await navigator.gpu?.requestAdapter();\n        if (!adapter) {\n            throw new Error('Couldn\\'t request WebGPU adapter.');\n        }\n\n        device = await adapter.requestDevice();\n        if (!device) {\n            throw new Error('Couldn\\'t request WebGPU device.');\n        }\n\n        // Set up error handling for device\n        device.addEventListener('uncapturederror', (event) => {\n            console.error('WebGPU device error:', event.error);\n        });\n\n        // Get or create canvas\n        canvas = options.canvas || document.querySelector('canvas');\n        if (!canvas) {\n            canvas = document.createElement('canvas');\n        }\n\n        let container = null;\n        if (options.containerId) {\n            container = document.getElementById(options.containerId);\n            if (!container) {\n                throw new Error(`Container with ID '${options.containerId}' not found.`);\n            }\n            container.appendChild(canvas);\n            width = container.clientWidth;\n            height = container.clientHeight;\n            canvas.style.display = 'block';\n        } else {\n            if (!options.canvas) {\n                document.body.appendChild(canvas);\n            }\n            width = window.innerWidth;\n            height = window.innerHeight;\n        }\n\n        if (options.width) width = options.width;\n        if (options.height) height = options.height;\n\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n        width *= 2\n        height *= 2\n        canvas.width = width;\n        canvas.height = height;\n\n        // Configure WebGPU context\n        ctx = canvas.getContext('webgpu');\n        if (!ctx) {\n            throw new Error('Couldn\\'t get WebGPU context from canvas.');\n        }\n\n        canvasPresentationFormat = navigator.gpu.getPreferredCanvasFormat();\n        ctx.configure({\n            device,\n            format: canvasPresentationFormat,\n            alphaMode: 'premultiplied'\n        });\n\n        // Add keyboard shortcut for saving canvas\n        window.addEventListener('keydown', (e) => {\n            if (e.key === 's') {\n                const a = document.createElement('a');\n                a.href = canvas.toDataURL();\n                a.download = 'webgpu-image-' + new Date().toISOString().replace(/:/g, '-') + '.png';\n                a.click();\n            }\n        });\n\n        // In your WebGPU initialization (e.g. after device, ctx, canvasPresentationFormat are set):\n        // _setWebGPUContext(device, ctx, canvasPresentationFormat);\n\n        // Export reference variables to global scope for convenience\n        return { device, canvas, width, height };\n    } catch (error) {\n        throw new Error(`Failed to initialize canvas: ${error.message}`);\n    }\n}\n\n// Check if WebGPU is supported in the current browser\nexport function isWebGPUSupported() {\n    return typeof navigator !== 'undefined' && navigator && ('gpu' in navigator);\n}\n\n// Utility to create a promise that resolves when the DOM is loaded\nexport function domReady() {\n    return new Promise(resolve => {\n        if (document.readyState === 'complete' || document.readyState === 'interactive') {\n            resolve();\n        } else {\n            document.addEventListener('DOMContentLoaded', () => resolve());\n        }\n    });\n}\n\n// Initialize the library and canvas in one call\nexport async function init(options = {}) {\n    await domReady();\n    await initCanvas(options);\n    if (options.mouse) createMouseBuffer();\n    if (options.time) createTimeBuffer();\n    createRenderPass();\n    if (options.feedback) createMatchPass();\n}","/**\n * WebGPU Core Module\n * Provides basic WebGPU functionality including buffer and texture creation.\n * This module is designed to be used with the WebGPU API and requires a compatible browser.\n */\n\nimport { device } from './canvas.js';\n\n/**\n * Create WebGPU buffer\n * @class\n */\nexport class Buffer {\n    /**\n     * Create a WebGPU buffer\n     * @param {string} [name=''] - Name for the buffer\n     * @param {Float32Array|Array} data - Data to store in buffer\n     * @throws {Error} If device is not initialized or buffer creation fails\n     */\n    constructor(name, data) {\n        if (!device) {\n            throw new Error('Buffer: WebGPU device not initialized. Call initCanvas() first.');\n        }\n\n        try {\n            this.name = name;\n\n            // Convert array to Float32Array if needed\n            if (Array.isArray(data)) {\n                data = new Float32Array(data);\n            } else if (!(data instanceof Float32Array)) {\n                throw new Error('Buffer: Data must be an Array or Float32Array');\n            }\n\n            this.data = data;\n            this.size = data.byteLength;\n\n            // Create the GPU buffer\n            this.buffer = device.createBuffer({\n                label: this.name,\n                size: this.size,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n                mappedAtCreation: true\n            });\n\n            // Write data to the buffer\n            new Float32Array(this.buffer.getMappedRange()).set(data);\n            this.buffer.unmap();\n\n            // Create resource binding\n            this.resource = { buffer: this.buffer };\n        } catch (error) {\n            throw new Error(`Failed to create Buffer: ${error.message}`);\n        }\n    }\n\n    /**\n     * Update buffer data\n     * @param {Float32Array|Array} data - New data for the buffer\n     */\n    update(data) {\n        if (!data || (!Array.isArray(data) && !(data instanceof Float32Array))) {\n            throw new Error('Buffer.update: Data must be an Array or Float32Array');\n        }\n\n        try {\n            // Convert array to Float32Array if needed\n            if (Array.isArray(data)) {\n                data = new Float32Array(data);\n            }\n\n            // Update data\n            device.queue.writeBuffer(this.buffer, 0, data);\n            this.data = data;\n        } catch (error) {\n            throw new Error(`Failed to update Buffer: ${error.message}`);\n        }\n    }\n\n    /**\n     * Get binding code for this buffer\n     * @param {number} index - Binding index for the buffer\n     * @returns {string} WGSL binding code for the buffer\n     * @throws {Error} If buffer resource is not initialized\n     */\n    getBindingCode(index) {\n        if (!this.resource || !this.resource.buffer) {\n            throw new Error('Buffer.getBindingCode: Buffer resource not initialized');\n        }\n\n        let bufferType = 'f32';\n        if (this.struct) bufferType = this.struct.name;\n        else {\n            if (this.size == 4) bufferType = 'f32';\n            else if (this.size == 8) bufferType = 'vec2f';\n            else if (this.size == 12) bufferType = 'vec3f';\n            else if (this.size == 16) bufferType = 'vec4f';\n        }\n        if (this.isArray) bufferType = `array<${bufferType}>`;\n        return `@group(0) @binding(${index}) var<storage, read_write> ${this.name}: ${bufferType};`\n    }\n\n    async getData(){\n        // get the data from the buffer\n        const readBuffer = device.createBuffer({\n            size: this.size,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n\n        // Step 2: Create a command encoder and copy the buffer\n        const commandEncoder = device.createCommandEncoder();\n        commandEncoder.copyBufferToBuffer(\n            this.buffer, // source buffer\n            0,           // source offset\n            readBuffer,  // destination buffer\n            0,           // destination offset\n            this.size    // size\n        );\n\n        // Submit the commands\n        const commands = commandEncoder.finish();\n        device.queue.submit([commands]);\n\n        // Step 3: Map the read buffer and read the data\n        await readBuffer.mapAsync(GPUMapMode.READ);\n        const copyArrayBuffer = readBuffer.getMappedRange();\n\n        // Assuming the data is float32\n        const newdata = [...new Float32Array(copyArrayBuffer)]\n\n        // Don't forget to unmap the buffer\n        readBuffer.unmap();\n        return newdata\n    }\n}\n\n/**\n * WebGPU Texture wrapper\n * @class\n */\nexport class Texture {\n    /**\n     * Create a WebGPU texture\n     * @param {string} [name=''] - Name for the texture\n     * @param {number} [width=512] - Texture width\n     * @param {number} [height=512] - Texture height\n     * @param {GPUTextureFormat} [format='rgba8unorm'] - Texture format\n     * @throws {Error} If device is not initialized or texture creation fails\n     */\n    constructor(name = '', width = 512, height = 512, format = 'rgba8unorm') {\n        if (!device) {\n            throw new Error('Texture: WebGPU device not initialized. Call initCanvas() first.');\n        }\n\n        try {\n            this.name = name;\n            this.width = width;\n            this.height = height;\n            this.format = format;\n\n            // Create the texture\n            this.texture = device.createTexture({\n                label: this.name,\n                size: [width, height, 1],\n                format,\n                usage: GPUTextureUsage.COPY_DST |\n                    GPUTextureUsage.STORAGE_BINDING |\n                    GPUTextureUsage.TEXTURE_BINDING\n            });\n\n            // Create texture view\n            this.view = this.texture.createView();\n            this.resource = this.view;\n        } catch (error) {\n            throw new Error(`Failed to create Texture: ${error.message}`);\n        }\n    }\n\n    /**\n     * Get binding for this texture in read mode\n     * @returns {GPUTextureView} Texture view for binding\n     */\n    read() {\n        return new TextureBindingHelper(this, 'read');\n    }\n\n    /**\n     * Get binding for this texture in write mode\n     * @returns {GPUTextureView} Texture view for binding\n     */\n    write() {\n        return new TextureBindingHelper(this, 'write');\n    }\n}\nfunction TextureBindingHelper(texture, readOrWrite = 'read') {\n    this.texture = texture;\n    this.readOrWrite = readOrWrite;\n    this.resource = texture.resource\n    this.name = texture.name;\n\n    this.getBindingCode = (bindingIndex) => {\n        if (this.readOrWrite === 'read' && this.texture.format == 'rgba8unorm') {\n            return `@group(0) @binding(${bindingIndex}) var ${this.texture.name}: texture_2d<f32>;`\n        }\n        return `@group(0) @binding(${bindingIndex}) var ${this.texture.name}: texture_storage_2d<${this.texture.format}, ${this.readOrWrite}>;`\n    }\n}\n","/**\n * @file WebGPU shader noise utilities\n * Provides noise functions for WGSL shaders\n */\n\nimport { Buffer } from './core.js';\n\nlet noiseBuffer = null;\n\n/**\n * Get WGSL code for noise functions\n * @returns {string} WGSL noise functions code\n */\nexport function getNoiseCode() {\n    // Create a noise offset buffer if it doesn't exist\n    if (!noiseBuffer) {\n        noiseBuffer = new Buffer([Math.random() * 1000, Math.random() * 1000, Math.random() * 1000], 'noiseOffset');\n    }\n\n    // Combine noise function implementations\n    return `\n    ${wgslNoise}\n    ${wgslNoise2}\n    `;\n}\n\n/**\n * Simple 1D noise function for WGSL\n * @type {string}\n */\nexport const wgslNoise = `\nfn rand(n: f32) -> f32 { return fract(sin(438.347 * n / 10000)); }\nfn noise(p: f32) -> f32 {\n  let pVal = p+noiseOffset.x;\n  let fl = floor(pVal);\n  let fc = fract(pVal);\n  return mix(rand(fl), rand(fl + 1.), fc);\n}\n`;\n\n/**\n * 2D simplex noise implementation for WGSL\n * @type {string}\n */\nexport const wgslNoise2 = \n`fn mod289(x: vec2<f32>) -> vec2<f32> {return x - floor(x * (1. / 289.)) * 289.;}\nfn mod289_3(x: vec3<f32>) -> vec3<f32> {return x - floor(x * (1. / 289.)) * 289.;}\nfn permute3(x: vec3<f32>) -> vec3<f32> {return mod289_3(((x * 34.) + 1.) * x);}\nfn noise2(v: vec2<f32>) -> f32 {\n  let v2 = v * .4 + noiseOffset.xy;\n  let C = vec4(\n      0.211324865405187, // (3.0-sqrt(3.0))/6.0\n      0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n      -0.577350269189626, // -1.0 + 2.0 * C.x\n      0.024390243902439 // 1.0 / 41.0\n  );\n  var i = floor(v2 + dot(v2, C.yy));\n  let x0 = v2 - i + dot(i, C.xx);\n  var i1 = select(vec2(0., 1.), vec2(1., 0.), x0.x > x0.y);\n  var x12 = x0.xyxy + C.xxzz;\n  x12.x = x12.x - i1.x;\n  x12.y = x12.y - i1.y;\n  i = mod289(i); // Avoid truncation effects in permutation\n  var p = permute3(permute3(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.));\n  var m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3(0.));\n  m *= m;\n  m *= m;\n  let x = 2. * fract(p * C.www) - 1.;\n  let h = abs(x) - 0.5;\n  let ox = floor(x + 0.5);\n  let a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  let g = vec3(a0.x * x0.x + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw);\n  return 130. * dot(m, g);\n}`;\n\n/**\n * 3D simplex noise implementation for WGSL\n * @type {string}\n */\nexport const wgslNoise3 = `\nfn mod289_f(x: f32) -> f32 { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfn mod289_vec3(x: vec3<f32>) -> vec3<f32> { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfn mod289_vec4(x: vec4<f32>) -> vec4<f32> { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfn permute_vec4(x: vec4<f32>) -> vec4<f32> { return mod289_vec4(((x * 34.0) + 1.0) * x); }\nfn taylorInvSqrt_f(r: f32) -> f32 { return 1.79284291400159 - 0.85373472095314 * r; }\nfn taylorInvSqrt_vec4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfn noise3(v: vec3<f32>) -> f32 {\n  let C = vec4<f32>(\n    0.1381966, // 1/6\n    0.2763932, // 1/3\n    0.5,\n    -0.5\n  );\n  \n  // First corner\n  var i = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n  \n  // Other corners\n  let g = step(x0.yzx, x0.xyz);\n  let l = 1.0 - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n  \n  let x1 = x0 - i1 + C.xxx;\n  let x2 = x0 - i2 + C.yyy;\n  let x3 = x0 - 0.5;\n  \n  // Permutations\n  i = mod289_vec3(i); // Avoid truncation effects in permutation\n  let p = permute_vec4(permute_vec4(permute_vec4(\n    i.z + vec4<f32>(0.0, i1.z, i2.z, 1.0))\n    + i.y + vec4<f32>(0.0, i1.y, i2.y, 1.0))\n    + i.x + vec4<f32>(0.0, i1.x, i2.x, 1.0));\n    \n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  let j = p - 49.0 * floor(p * (1.0 / 49.0));  // mod(p,7*7)\n  \n  let x_ = floor(j * (1.0 / 7.0));\n  let y_ = floor(j - 7.0 * x_);  // mod(j,N)\n  \n  let x = x_ * (2.0 / 7.0) + 0.5 / 7.0 - 1.0;\n  let y = y_ * (2.0 / 7.0) + 0.5 / 7.0 - 1.0;\n  \n  let h = 1.0 - abs(x) - abs(y);\n  \n  let b0 = vec4<f32>(x.xy, y.xy);\n  let b1 = vec4<f32>(x.zw, y.zw);\n  \n  let s0 = floor(b0) * 2.0 + 1.0;\n  let s1 = floor(b1) * 2.0 + 1.0;\n  let sh = -step(h, vec4<f32>(0.0));\n  \n  let a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  let a1 = b1.xzyw + s1.xzyw * sh.zzww;\n  \n  var p0 = vec3<f32>(a0.xy, h.x);\n  var p1 = vec3<f32>(a0.zw, h.y);\n  var p2 = vec3<f32>(a1.xy, h.z);\n  var p3 = vec3<f32>(a1.zw, h.w);\n  \n  // Normalise gradients\n  let norm = taylorInvSqrt_vec4(vec4<f32>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  \n  // Mix final noise value\n  var m = max(0.6 - vec4<f32>(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), vec4<f32>(0.0));\n  m = m * m;\n  return 42.0 * dot(m * m, vec4<f32>(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n`;\n\n/**\n * FBM (Fractal Brownian Motion) noise for WGSL\n * @type {string}\n */\nexport const wgslFBM = `\nfn fbm(p: vec2<f32>, octaves: i32) -> f32 {\n    var value = 0.0;\n    var amplitude = 0.5;\n    var frequency = 1.0;\n    var p2 = p + noiseOffset.xy * 10.0;\n    \n    for (var i = 0; i < octaves; i = i + 1) {\n        value += amplitude * noise2(p2 * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    \n    return value;\n}\n`;\n\n/**\n * WGSL function for voronoi noise\n * @type {string}\n */\nexport const wgslVoronoi = `\nfn voronoi(uv: vec2<f32>, scale: f32, seed: f32) -> f32 {\n    let s = scale;\n    let iuv = floor(uv * s);\n    let fuv = fract(uv * s);\n    var min_dist = 1.0;\n    \n    for (var y: i32 = -1; y <= 1; y = y + 1) {\n        for (var x: i32 = -1; x <= 1; x = x + 1) {\n            let neighbor = vec2<f32>(f32(x), f32(y));\n            let point = 0.5 + 0.5 * sin(seed + 6.2831 * rand(rand(iuv.x + neighbor.x + seed) + iuv.y + neighbor.y));\n            let diff = neighbor + point - fuv;\n            let dist = length(diff);\n            min_dist = min(min_dist, dist);\n        }\n    }\n    \n    return min_dist;\n}\n`;\n\nexport default { \n    getNoiseCode, \n    wgslNoise, \n    wgslNoise2, \n    wgslNoise3, \n    wgslFBM, \n    wgslVoronoi,\n    noiseBuffer \n};\n","/**\n * @file WebGPU ray casting utilities for WGSL shaders\n * Provides helper functions for ray-based rendering techniques\n */\n\n/**\n * WGSL code for 2D vector rotation\n * @type {string}\n */\nexport const wgsl_rotate = `fn rotate(v: vec2<f32>, a: f32) -> vec2<f32> {\n    let s = sin(a);\n    let c = cos(a);\n    return vec2<f32>(c * v.x - s * v.y, s * v.x + c * v.y);\n    }`;\n\n/**\n * WGSL code for rotating a vector around the Y axis\n * @type {string}\n */\nexport const wgsl_rotate_y = `fn rotate_y(vec: vec3<f32>, angle: f32) -> vec3<f32> {\n      let cos_theta = cos(angle);\n      let sin_theta = sin(angle);\n      return vec3<f32>(\n          vec.x * cos_theta + vec.z * sin_theta,\n          vec.y,\n          -vec.x * sin_theta + vec.z * cos_theta\n      );\n  }`;\n\n/**\n * WGSL struct definitions for ray casting\n * @type {string}\n */\nexport const wgsl_rayStruct = `\n  struct hit {\n    dist: f32,\n    index: i32,\n  };\n\n  struct Ray {\n    ro: vec3<f32>,\n    rd: vec3<f32>,\n  };`;\n\n/**\n * Default camera code for ray generation\n * @type {string}\n */\nexport let cameraCode = `\n  let theta = 0.0;\n  let camPos = vec3<f32>(0.0, 0.0, 1000.0);\n`;\n\n/**\n * Creates a WGSL function for ray generation\n * @param {Object} [options] - Options for ray generation\n * @param {string} [options.customCameraCode] - Custom camera setup code\n * @param {number} [options.width] - Canvas width\n * @param {number} [options.height] - Canvas height\n * @returns {string} WGSL function for ray generation\n */\nexport function createGetRayFunction(options = {}) {\n    const customCameraCode = options.customCameraCode || cameraCode;\n    const width = options.width || globalThis.width || 1000;\n    const height = options.height || globalThis.height || 1000;\n\n    return `\nfn getRay(x: i32, y: i32) -> Ray {\n    ${customCameraCode}\n    camPos = rotate_y(camPos, theta);\n    let lookAt = vec3<f32>(0.0, 0.0, 0.0);\n    let forward = normalize(lookAt - camPos);\n\n    // Calculate right vector (perpendicular to forward and world up)\n    let worldUp = vec3<f32>(0.0, 1.0, 0.0);\n    let right = normalize(cross(forward, worldUp));\n\n    // Calculate camera's up vector\n    let up = normalize(cross(right, forward));\n\n    // Screen coordinates relative to center\n    let screenX = f32(x) / 2 - ${width / 4};\n    let screenY = f32(y) / 2 - ${height / 4};\n\n    // Scale factors to control orthographic view size\n    let orthoScale = 1.0; // Adjust as needed\n\n    // For orthographic, we offset the ray origin in the plane perpendicular to viewing direction\n    let ro = camPos + (right * screenX * orthoScale) + (up * screenY * orthoScale);\n\n    // All rays have the same direction (parallel)\n    let rd = forward;\n\n    return Ray(ro, rd);\n  }\n`;\n}\n\n/**\n * Sets custom camera code for ray generation\n * @param {string} code - WGSL camera initialization code\n */\nexport function setCameraCode(code) {\n    if (typeof code !== 'string') {\n        throw new Error('setCameraCode: Camera code must be a string');\n    }\n    cameraCode = code;\n}\n\n/**\n * WGSL code for ray-sphere intersection tests\n * @type {string}\n */\nexport const wgsl_rayToSphere = `\nfn rayToSphere(ro: vec3<f32>, rd: vec3<f32>, sph: sphere) -> f32 {\n    let oc = ro - sph.pos;\n    // Since rd is typically normalized, a = dot(rd,rd) = 1.0\n    \n    let b = dot(oc, rd);\n    let c = dot(oc, oc) - sph.r * sph.r;\n    let discriminant = b * b - c;\n    \n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n\n    let t1 = -b - sqrt(discriminant);\n    let t2 = -b + sqrt(discriminant);\n\n    if (t1 > 0.0) {\n      return t1;\n    }\n    if (t2 > 0.0) {\n      return t2;\n    } else {\n      return -1.0;\n    }\n}\nfn isInSphere(pos: vec3<f32>, sph: sphere) -> bool {\n  return length(pos - sph.pos) <= sph.r;\n}\n`;\n\n/**\n * WGSL code for ray-plane intersection tests\n * @type {string}\n */\nexport const wgsl_rayToPlane = `\nstruct Plane {\n  normal: vec3<f32>,\n  distance: f32,\n};\n\nfn rayToPlane(ro: vec3<f32>, rd: vec3<f32>, plane: Plane) -> f32 {\n  let denom = dot(plane.normal, rd);\n  \n  // Check if ray is parallel to the plane\n  if (abs(denom) < 0.0001) {\n    return -1.0;\n  }\n  \n  let t = -(dot(ro, plane.normal) + plane.distance) / denom;\n  \n  // Only return positive intersection distance (in front of the ray)\n  if (t < 0.0) {\n    return -1.0;\n  }\n  \n  return t;\n}\n`;\n\n/**\n * WGSL code for ray-box intersection tests\n * @type {string}\n */\nexport const wgsl_rayToBox = `\nstruct Box {\n  min: vec3<f32>,\n  max: vec3<f32>,\n};\n\nfn rayToBox(ro: vec3<f32>, rd: vec3<f32>, box: Box) -> f32 {\n  let tMin = (box.min - ro) / rd;\n  let tMax = (box.max - ro) / rd;\n  \n  let t1 = min(tMin, tMax);\n  let t2 = max(tMin, tMax);\n  \n  let tNear = max(max(t1.x, t1.y), t1.z);\n  let tFar = min(min(t2.x, t2.y), t2.z);\n  \n  // Box is behind the ray or ray misses box\n  if (tNear > tFar || tFar < 0.0) {\n    return -1.0;\n  }\n  \n  // Return nearest positive hit\n  return tNear > 0.0 ? tNear : tFar;\n}\n\nfn isInBox(pos: vec3<f32>, box: Box) -> bool {\n  return all(pos >= box.min) && all(pos <= box.max);\n}\n`;\n\n/**\n * WGSL material definition for use with ray tracing\n * @type {string}\n */\nexport const wgsl_material = `\nstruct Material {\n  albedo: vec3<f32>,\n  roughness: f32,\n  metallic: f32,\n  emission: vec3<f32>,\n  ior: f32,\n};\n\nfn defaultMaterial() -> Material {\n  return Material(\n    vec3<f32>(0.8, 0.8, 0.8), // albedo (diffuse color)\n    0.5,                       // roughness\n    0.0,                       // metallic\n    vec3<f32>(0.0, 0.0, 0.0), // emission\n    1.45                       // index of refraction\n  );\n}\n`;\n\n/**\n * WGSL code for calculating surface normals\n * @type {string}\n */\nexport const wgsl_normals = `\nfn sphereNormal(hitPos: vec3<f32>, sphere: sphere) -> vec3<f32> {\n  return normalize(hitPos - sphere.pos);\n}\n\nfn planeNormal(plane: Plane) -> vec3<f32> {\n  return plane.normal;\n}\n\nfn boxNormal(hitPos: vec3<f32>, box: Box) -> vec3<f32> {\n  // Find the face that was hit by checking which component is closest to the respective face\n  let center = (box.min + box.max) * 0.5;\n  let d = hitPos - center;\n  let s = (box.max - box.min) * 0.5;\n  \n  let bias = 0.0001; // Small bias to avoid precision errors\n  let nx = d.x / (s.x + bias);\n  let ny = d.y / (s.y + bias);\n  let nz = d.z / (s.z + bias);\n  \n  // Return normal for the face with largest value (closest to surface)\n  if (abs(nx) > abs(ny) && abs(nx) > abs(nz)) {\n    return vec3<f32>(sign(nx), 0.0, 0.0);\n  } else if (abs(ny) > abs(nz)) {\n    return vec3<f32>(0.0, sign(ny), 0.0);\n  } else {\n    return vec3<f32>(0.0, 0.0, sign(nz));\n  }\n}\n`;\n\nexport default {\n    wgsl_rotate,\n    wgsl_rotate_y,\n    wgsl_rayStruct,\n    cameraCode,\n    createGetRayFunction,\n    setCameraCode,\n    wgsl_rayToSphere,\n    wgsl_rayToPlane,\n    wgsl_rayToBox,\n    wgsl_material,\n    wgsl_normals\n};\n","// wgsl.js - WGSL template literal with builder pattern\n\nimport { height, width } from './canvas.js';\n\nclass WGSLParser {\n  constructor(code) {\n    this.code = code;\n    this.position = 0;\n    this.functions = [];\n    this.body = [];\n  }\n\n  peek(offset = 0) {\n    return this.code[this.position + offset] || '';\n  }\n\n  advance() {\n    return this.code[this.position++] || '';\n  }\n\n  skipWhitespace() {\n    while (this.position < this.code.length && /\\s/.test(this.peek())) {\n      this.advance();\n    }\n  }\n\n  skipComment() {\n    if (this.peek() === '/' && this.peek(1) === '/') {\n      // Skip single line comment\n      while (this.position < this.code.length && this.peek() !== '\\n') {\n        this.advance();\n      }\n      return true;\n    }\n    if (this.peek() === '/' && this.peek(1) === '*') {\n      // Skip block comment\n      this.advance(); // skip '/'\n      this.advance(); // skip '*'\n      while (this.position < this.code.length - 1) {\n        if (this.peek() === '*' && this.peek(1) === '/') {\n          this.advance(); // skip '*'\n          this.advance(); // skip '/'\n          break;\n        }\n        this.advance();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  skipWhitespaceAndComments() {\n    let skipped = true;\n    while (skipped) {\n      const before = this.position;\n      this.skipWhitespace();\n      this.skipComment();\n      skipped = this.position > before;\n    }\n  }\n\n  readIdentifier() {\n    let result = '';\n    while (this.position < this.code.length && /[a-zA-Z0-9_]/.test(this.peek())) {\n      result += this.advance();\n    }\n    return result;\n  }\n\n  matchKeyword(keyword) {\n    const start = this.position;\n    this.skipWhitespaceAndComments();\n    \n    for (let i = 0; i < keyword.length; i++) {\n      if (this.peek() !== keyword[i]) {\n        this.position = start;\n        return false;\n      }\n      this.advance();\n    }\n    \n    // Make sure it's not part of a longer identifier\n    if (/[a-zA-Z0-9_]/.test(this.peek())) {\n      this.position = start;\n      return false;\n    }\n    \n    return true;\n  }\n\n  findMatchingBrace() {\n    if (this.peek() !== '{') return -1;\n    \n    const start = this.position;\n    this.advance(); // skip opening brace\n    \n    let braceCount = 1;\n    while (this.position < this.code.length && braceCount > 0) {\n      this.skipWhitespaceAndComments();\n      \n      if (this.peek() === '{') {\n        braceCount++;\n        this.advance();\n      } else if (this.peek() === '}') {\n        braceCount--;\n        this.advance();\n      } else if (this.peek() === '\"') {\n        // Skip string literals\n        this.advance(); // skip opening quote\n        while (this.position < this.code.length && this.peek() !== '\"') {\n          if (this.peek() === '\\\\') {\n            this.advance(); // skip escape character\n          }\n          this.advance();\n        }\n        if (this.peek() === '\"') this.advance(); // skip closing quote\n      } else {\n        this.advance();\n      }\n    }\n    \n    return braceCount === 0 ? this.position : -1;\n  }\n\n  parseFunction() {\n    const start = this.position;\n    \n    // Skip 'fn'\n    if (!this.matchKeyword('fn')) return null;\n    \n    this.skipWhitespaceAndComments();\n    \n    // Read function name\n    const name = this.readIdentifier();\n    if (!name) {\n      this.position = start;\n      return null;\n    }\n    \n    this.skipWhitespaceAndComments();\n    \n    // Find parameters\n    if (this.peek() !== '(') {\n      this.position = start;\n      return null;\n    }\n    \n    // Skip to after parameters\n    let parenCount = 1;\n    this.advance(); // skip opening paren\n    while (this.position < this.code.length && parenCount > 0) {\n      if (this.peek() === '(') parenCount++;\n      else if (this.peek() === ')') parenCount--;\n      this.advance();\n    }\n    \n    this.skipWhitespaceAndComments();\n    \n    // Skip return type if present\n    if (this.peek() === '-' && this.peek(1) === '>') {\n      this.advance(); // skip '-'\n      this.advance(); // skip '>'\n      this.skipWhitespaceAndComments();\n      \n      // Skip return type (could be complex like vec4<f32>)\n      while (this.position < this.code.length && \n             this.peek() !== '{' && \n             !/\\s/.test(this.peek())) {\n        if (this.peek() === '<') {\n          // Skip generic parameters\n          let angleCount = 1;\n          this.advance();\n          while (this.position < this.code.length && angleCount > 0) {\n            if (this.peek() === '<') angleCount++;\n            else if (this.peek() === '>') angleCount--;\n            this.advance();\n          }\n        } else {\n          this.advance();\n        }\n      }\n    }\n    \n    this.skipWhitespaceAndComments();\n    \n    // Find function body\n    const bodyEnd = this.findMatchingBrace();\n    if (bodyEnd === -1) {\n      this.position = start;\n      return null;\n    }\n    \n    const functionCode = this.code.slice(start, bodyEnd).trim();\n    return functionCode;\n  }\n\n  parse() {\n    while (this.position < this.code.length) {\n      this.skipWhitespaceAndComments();\n      \n      if (this.position >= this.code.length) break;\n      \n      const fnCode = this.parseFunction();\n      if (fnCode) {\n        this.functions.push(fnCode);\n      } else {\n        // Not a function, add to body\n        const lineStart = this.position;\n        while (this.position < this.code.length && this.peek() !== '\\n') {\n          this.advance();\n        }\n        if (this.peek() === '\\n') this.advance();\n        \n        const line = this.code.slice(lineStart, this.position).trim();\n        if (line) {\n          this.body.push(line);\n        }\n      }\n    }\n    \n    return {\n      functions: this.functions,\n      body: this.body.join('\\n')\n    };\n  }\n}\n\nexport function extractFunctionsAndBody(code) {\n  try {\n    const parser = new WGSLParser(code);\n    return parser.parse();\n  } catch (error) {\n    console.warn('Parser failed, falling back to simple approach:', error);\n    \n    // Fallback: simple splitting approach\n    const lines = code.split('\\n').map(line => line.trim()).filter(line => line);\n    const functions = [];\n    const body = [];\n    \n    let inFunction = false;\n    let braceCount = 0;\n    let currentFunction = [];\n    \n    for (const line of lines) {\n      if (line.startsWith('fn ')) {\n        inFunction = true;\n        currentFunction = [line];\n        braceCount = (line.match(/\\{/g) || []).length - (line.match(/\\}/g) || []).length;\n      } else if (inFunction) {\n        currentFunction.push(line);\n        braceCount += (line.match(/\\{/g) || []).length - (line.match(/\\}/g) || []).length;\n        \n        if (braceCount === 0) {\n          functions.push(currentFunction.join('\\n'));\n          inFunction = false;\n          currentFunction = [];\n        }\n      } else {\n        body.push(line);\n      }\n    }\n    \n    return {\n      functions,\n      body: body.join('\\n')\n    };\n  }\n}\n\nclass WGSLBuilder {\n  constructor() {\n    this.functions = [];\n    this.bindings = [];\n    this.structs = [];\n  }\n\n  fn(name, params, returnType, body) {\n    const fnCode = `fn ${name}(${params}) -> ${returnType} {\\n${body}\\n}`;\n    this.functions.push(fnCode);\n    return this; // for chaining\n  }\n\n  binding(group, binding, type, name) {\n    this.bindings.push(`@group(${group}) @binding(${binding}) var ${name}: ${type};`);\n    return this;\n  }\n\n  struct(name, body) {\n    this.structs.push(`struct ${name} {\\n${body}\\n}`);\n    return this;\n  }\n\n  get main() {\n    // Return a template literal function\n    return (strings, ...values) => {\n      // Build the complete code\n      let code = '';\n      \n      // Add bindings\n      if (this.bindings.length > 0) {\n        code += this.bindings.join('\\n') + '\\n\\n';\n      }\n      \n      // Add structs\n      if (this.structs.length > 0) {\n        code += this.structs.join('\\n\\n') + '\\n\\n';\n      }\n      \n      // Add functions\n      if (this.functions.length > 0) {\n        code += this.functions.join('\\n\\n') + '\\n\\n';\n      }\n      \n      // Add main body from template literal\n      const mainBody = String.raw({ raw: strings }, ...values);\n      code += mainBody;\n      \n      // Check if main function already exists\n      if (/fn\\s+main\\s*\\(/.test(code)) {\n        return code;\n      }\n      \n      // Use existing parser to separate any remaining functions from body\n      const { functions: parsedFunctions, body } = extractFunctionsAndBody(code);\n      \n      // Build final result\n      let result = '';\n      \n      if (parsedFunctions.length > 0) {\n        result += parsedFunctions.join('\\n\\n') + '\\n\\n';\n      }\n      \n      result += '@compute @workgroup_size(1)\\n';\n      result += 'fn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n';\n      \n      if (body) {\n        const indentedBody = body.split('\\n')\n          .map(line => line.trim() ? '  ' + line : line)\n          .join('\\n');\n        result += indentedBody + '\\n';\n      }\n      \n      result += '}';\n      \n      return result;\n    };\n  }\n}\n\n// Original template literal function\nexport function wgsl(strings, ...values) {\n  let code = String.raw({ raw: strings }, ...values);\n\n  // Replace width and height placeholders\n  code = code.replace(/\\bwidth\\b/g, width.toFixed(2));\n  code = code.replace(/\\bheight\\b/g, height.toFixed(2));\n\n  // Remove leading/trailing whitespace but preserve internal structure\n  code = code.trim();\n  \n  // If user already wrote main function, return as-is\n  if (/fn\\s+main\\s*\\(/.test(code)) {\n    return code;\n  }\n  \n  // Extract helper functions and body\n  const { functions, body } = extractFunctionsAndBody(code);\n  \n  // Build the final WGSL code\n  let result = '';\n  \n  // Add functions first\n  if (functions.length > 0) {\n    result += functions.join('\\n\\n') + '\\n\\n';\n  }\n  \n  // Add main function with body\n  result += '@compute @workgroup_size(1)\\n';\n  result += 'fn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n';\n  \n  if (body) {\n    // Indent the body\n    const indentedBody = body.split('\\n')\n      .map(line => line.trim() ? '  ' + line : line)\n      .join('\\n');\n    result += indentedBody + '\\n';\n  }\n  \n  result += '}';\n  \n  return result;\n}\n\n// Add compute builder to wgsl\nwgsl.compute = () => new WGSLBuilder();\n// Allow setting width for parsing stage\nwgsl.setWidth = (value) => { wgsl.width = value; };","/**\n * WebGPU Utils - A utility library for WebGPU development\n * @module webgpu-utils\n */\n\n\n/**\n * Library version\n * @type {string}\n */\nexport const VERSION = '0.1.0';\n\nexport * from './core.js';\nexport * from './canvas.js';\nexport * from './camera.js';\nexport * from './noise.js';\nexport * from './passes.js';\nexport * from './render_passes.js';\nexport * from './struct.js';\nexport * from './raycasting.js';\nexport * from './utilities.js';\nexport * from './wgsl.js';\n","/**\n * @file WebGPU camera utilities for WGSL shaders\n * Provides camera functions and perspective calculations for 3D rendering\n */\n\nimport { width, height } from './canvas.js';\n\n/**\n * Generates camera-related WGSL code\n * @param {Object} [options] - Camera configuration options\n * @param {number} [options.cameraDistance=250.0] - Base distance of camera from origin\n * @param {number} [options.rotationSpeed=0.01] - Camera rotation speed\n * @param {number} [options.fieldOfView=90.0] - Camera field of view in degrees\n * @param {number} [options.nearPlane=1.0] - Near clipping plane distance\n * @param {number} [options.farPlane=1000.0] - Far clipping plane distance\n * @param {number} [options.cameraY=-100.0] - Camera Y position\n * @returns {string} WGSL camera code\n */\nexport function getCamStuff(options = {}) {\n    const {\n        cameraDistance = 250.0,\n        rotationSpeed = 0.01,\n        fieldOfView = 90.0,\n        nearPlane = 1.0,\n        farPlane = 1000.0,\n        cameraY = -100.0\n    } = options;\n\n    return `\n    // Camera configuration constants\n    const BASE_CAMERA_DISTANCE = ${cameraDistance};\n    const ROTATION_SPEED = ${rotationSpeed};            // Adjust this to change rotation speed\n    const FIELD_OF_VIEW = ${fieldOfView};\n    const ASPECT_RATIO = ${width / height};\n    const NEAR_PLANE = ${nearPlane};\n    const FAR_PLANE = ${farPlane};\n    const CAMERA_UP = vec3 < f32 > (0.0, 1.0, 0.0);\n\n    // Orthographic parameters\n    const ORTHO_SIZE = 5.0;               // Size of the orthographic view (height)\n    const ORTHO_WIDTH = ORTHO_SIZE * ASPECT_RATIO;\n    const ORTHO_HEIGHT = ORTHO_SIZE;\n\n    fn calculateCameraPosition() -> vec3 < f32 > {\n        let angle = globalData[0].frame * ROTATION_SPEED;\n        return vec3 < f32 > (\n            cos(angle) * BASE_CAMERA_DISTANCE,\n            ${cameraY},\n            sin(angle) * BASE_CAMERA_DISTANCE\n        );\n    }\n\n    fn lookAt(eye: vec3 < f32 >, targetDir: vec3 < f32 >, up: vec3 < f32 >) -> mat4x4 < f32 > {\n        let f = normalize(targetDir - eye);\n        let s = normalize(cross(f, up));\n        let u = cross(s, f);\n\n        return mat4x4 < f32 > (\n            vec4 < f32 > (s.x, u.x, -f.x, 0.0),\n            vec4 < f32 > (s.y, u.y, -f.y, 0.0),\n            vec4 < f32 > (s.z, u.z, -f.z, 0.0),\n            vec4 < f32 > (-dot(s, eye), -dot(u, eye), dot(f, eye), 1.0)\n        );\n    }\n\n    fn perspectiveMatrix() -> mat4x4 < f32 > {\n        let fovRad = radians(FIELD_OF_VIEW);\n        let f = 1.0 / tan(fovRad / 2.0);\n\n        return mat4x4 < f32 > (\n            vec4 < f32 > (f / ASPECT_RATIO, 0.0, 0.0, 0.0),\n            vec4 < f32 > (0.0, f, 0.0, 0.0),\n            vec4 < f32 > (0.0, 0.0, (FAR_PLANE + NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), -1.0),\n            vec4 < f32 > (0.0, 0.0, (2.0 * FAR_PLANE * NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), 0.0)\n        );\n    }\n\n    fn worldToScreenPerspective(worldPos: vec3 < f32 >) -> vec2 < f32 > {\n        let cameraPos = calculateCameraPosition();\n        let viewMatrix = lookAt(cameraPos, vec3 < f32 > (0.0, 0.0, 0.0), CAMERA_UP);\n        let projMatrix = perspectiveMatrix();\n        let viewProj = projMatrix * viewMatrix;\n\n        // Transform to clip space\n        let clipPos = viewProj * vec4 < f32 > (worldPos, 1.0);\n\n        // Perspective division\n        let ndcPos = clipPos.xyz / clipPos.w;\n\n        // Convert to screen coordinates [0,1]\n        return vec2 < f32 > (\n            (ndcPos.x + 1.0) * 0.5,\n            (ndcPos.y + 1.0) * 0.5\n        );\n    }\n    `;\n}\n\n/**\n * Creates a static camera at a specific position\n * @param {Object} position - Camera position\n * @param {number} position.x - X coordinate\n * @param {number} position.y - Y coordinate\n * @param {number} position.z - Z coordinate\n * @param {Object} [target] - Camera target position (default: origin)\n * @param {number} [target.x=0] - Target X coordinate\n * @param {number} [target.y=0] - Target Y coordinate\n * @param {number} [target.z=0] - Target Z coordinate\n * @returns {string} WGSL code for a static camera\n */\nexport function createStaticCamera(position, target = { x: 0, y: 0, z: 0 }) {\n    if (!position || typeof position !== 'object' || \n        typeof position.x !== 'number' || \n        typeof position.y !== 'number' || \n        typeof position.z !== 'number') {\n        throw new Error('createStaticCamera: Valid position object with x, y, z coordinates is required');\n    }\n\n    return `\n    // Static camera configuration constants\n    const FIELD_OF_VIEW = 90.0;\n    const ASPECT_RATIO = ${width / height};\n    const NEAR_PLANE = 1.0;\n    const FAR_PLANE = 1000.0;\n    const CAMERA_UP = vec3 < f32 > (0.0, 1.0, 0.0);\n    \n    const CAMERA_POSITION = vec3<f32>(${position.x}, ${position.y}, ${position.z});\n    const CAMERA_TARGET = vec3<f32>(${target.x}, ${target.y}, ${target.z});\n\n    fn calculateCameraPosition() -> vec3 < f32 > {\n        return CAMERA_POSITION;\n    }\n\n    fn lookAt(eye: vec3 < f32 >, targetDir: vec3 < f32 >, up: vec3 < f32 >) -> mat4x4 < f32 > {\n        let f = normalize(targetDir - eye);\n        let s = normalize(cross(f, up));\n        let u = cross(s, f);\n\n        return mat4x4 < f32 > (\n            vec4 < f32 > (s.x, u.x, -f.x, 0.0),\n            vec4 < f32 > (s.y, u.y, -f.y, 0.0),\n            vec4 < f32 > (s.z, u.z, -f.z, 0.0),\n            vec4 < f32 > (-dot(s, eye), -dot(u, eye), dot(f, eye), 1.0)\n        );\n    }\n\n    fn perspectiveMatrix() -> mat4x4 < f32 > {\n        let fovRad = radians(FIELD_OF_VIEW);\n        let f = 1.0 / tan(fovRad / 2.0);\n\n        return mat4x4 < f32 > (\n            vec4 < f32 > (f / ASPECT_RATIO, 0.0, 0.0, 0.0),\n            vec4 < f32 > (0.0, f, 0.0, 0.0),\n            vec4 < f32 > (0.0, 0.0, (FAR_PLANE + NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), -1.0),\n            vec4 < f32 > (0.0, 0.0, (2.0 * FAR_PLANE * NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), 0.0)\n        );\n    }\n\n    fn worldToScreenPerspective(worldPos: vec3 < f32 >) -> vec2 < f32 > {\n        let cameraPos = calculateCameraPosition();\n        let viewMatrix = lookAt(cameraPos, CAMERA_TARGET, CAMERA_UP);\n        let projMatrix = perspectiveMatrix();\n        let viewProj = projMatrix * viewMatrix;\n\n        // Transform to clip space\n        let clipPos = viewProj * vec4 < f32 > (worldPos, 1.0);\n\n        // Perspective division\n        let ndcPos = clipPos.xyz / clipPos.w;\n\n        // Convert to screen coordinates [0,1]\n        return vec2 < f32 > (\n            (ndcPos.x + 1.0) * 0.5,\n            (ndcPos.y + 1.0) * 0.5\n        );\n    }\n    `;\n}\n\n/**\n * Creates a first-person camera controller WGSL code\n * @param {Object} [options] - First-person camera options\n * @param {Object} [options.initialPosition={ x: 0, y: 2, z: 5 }] - Starting position\n * @param {Object} [options.initialLookAt={ x: 0, y: 0, z: 0 }] - Initial look target\n * @param {number} [options.moveSpeed=0.1] - Camera movement speed\n * @param {number} [options.sensitivity=0.003] - Mouse look sensitivity\n * @returns {string} WGSL first-person camera code\n */\nexport function createFirstPersonCamera(options = {}) {\n    const {\n        initialPosition = { x: 0, y: 2, z: 5 },\n        initialLookAt = { x: 0, y: 0, z: 0 },\n        moveSpeed = 0.1,\n        sensitivity = 0.003\n    } = options;\n    \n    return `\n    // First-person camera constants\n    const CAMERA_MOVE_SPEED = ${moveSpeed};\n    const MOUSE_SENSITIVITY = ${sensitivity};\n    const FIELD_OF_VIEW = 70.0;\n    const ASPECT_RATIO = ${width / height};\n    const NEAR_PLANE = 0.1;\n    const FAR_PLANE = 1000.0;\n    const CAMERA_UP = vec3<f32>(0.0, 1.0, 0.0);\n    \n    // Camera state (should be fed from uniform buffer in real implementation)\n    var<private> camera_position = vec3<f32>(${initialPosition.x}, ${initialPosition.y}, ${initialPosition.z});\n    var<private> camera_front = normalize(vec3<f32>(${initialLookAt.x - initialPosition.x}, \n                                                   ${initialLookAt.y - initialPosition.y},\n                                                   ${initialLookAt.z - initialPosition.z}));\n    var<private> camera_right = normalize(cross(camera_front, CAMERA_UP));\n    var<private> camera_up = normalize(cross(camera_right, camera_front));\n    var<private> yaw = -90.0; // Default is looking along negative z\n    var<private> pitch = 0.0;\n    \n    fn updateCameraVectors() {\n        let direction = vec3<f32>(\n            cos(radians(yaw)) * cos(radians(pitch)),\n            sin(radians(pitch)),\n            sin(radians(yaw)) * cos(radians(pitch))\n        );\n        \n        camera_front = normalize(direction);\n        camera_right = normalize(cross(camera_front, CAMERA_UP));\n        camera_up = normalize(cross(camera_right, camera_front));\n    }\n    \n    fn moveCamera(direction: i32) {\n        switch direction {\n            case 0: { // Forward\n                camera_position += CAMERA_MOVE_SPEED * camera_front;\n            }\n            case 1: { // Backward\n                camera_position -= CAMERA_MOVE_SPEED * camera_front;\n            }\n            case 2: { // Left\n                camera_position -= CAMERA_MOVE_SPEED * camera_right;\n            }\n            case 3: { // Right\n                camera_position += CAMERA_MOVE_SPEED * camera_right;\n            }\n            case 4: { // Up\n                camera_position += CAMERA_MOVE_SPEED * CAMERA_UP;\n            }\n            case 5: { // Down\n                camera_position -= CAMERA_MOVE_SPEED * CAMERA_UP;\n            }\n            default: {}\n        }\n    }\n    \n    fn rotateCamera(xoffset: f32, yoffset: f32) {\n        yaw += xoffset * MOUSE_SENSITIVITY;\n        pitch += yoffset * MOUSE_SENSITIVITY;\n        \n        // Constrain pitch\n        pitch = clamp(pitch, -89.0, 89.0);\n        \n        updateCameraVectors();\n    }\n    \n    fn getViewMatrix() -> mat4x4<f32> {\n        let target = camera_position + camera_front;\n        return lookAt(camera_position, target, camera_up);\n    }\n    \n    fn lookAt(eye: vec3<f32>, target: vec3<f32>, up: vec3<f32>) -> mat4x4<f32> {\n        let f = normalize(target - eye);\n        let r = normalize(cross(f, up));\n        let u = cross(r, f);\n        \n        return mat4x4<f32>(\n            vec4<f32>(r.x, u.x, -f.x, 0.0),\n            vec4<f32>(r.y, u.y, -f.y, 0.0),\n            vec4<f32>(r.z, u.z, -f.z, 0.0),\n            vec4<f32>(-dot(r, eye), -dot(u, eye), dot(f, eye), 1.0)\n        );\n    }\n    \n    fn perspectiveMatrix() -> mat4x4<f32> {\n        let fovRad = radians(FIELD_OF_VIEW);\n        let f = 1.0 / tan(fovRad / 2.0);\n        \n        return mat4x4<f32>(\n            vec4<f32>(f / ASPECT_RATIO, 0.0, 0.0, 0.0),\n            vec4<f32>(0.0, f, 0.0, 0.0),\n            vec4<f32>(0.0, 0.0, (FAR_PLANE + NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), -1.0),\n            vec4<f32>(0.0, 0.0, (2.0 * FAR_PLANE * NEAR_PLANE) / (NEAR_PLANE - FAR_PLANE), 0.0)\n        );\n    }\n    \n    fn worldToScreenPerspective(worldPos: vec3<f32>) -> vec2<f32> {\n        let viewMatrix = getViewMatrix();\n        let projMatrix = perspectiveMatrix();\n        let viewProj = projMatrix * viewMatrix;\n        \n        // Transform to clip space\n        let clipPos = viewProj * vec4<f32>(worldPos, 1.0);\n        \n        // Perspective division\n        let ndcPos = clipPos.xyz / clipPos.w;\n        \n        // Convert to screen coordinates [0,1]\n        return vec2<f32>(\n            (ndcPos.x + 1.0) * 0.5,\n            (ndcPos.y + 1.0) * 0.5\n        );\n    }\n    `;\n}\n\nexport default {\n    getCamStuff,\n    createStaticCamera,\n    createFirstPersonCamera\n};\n"],"names":["Struct","constructor","name","data","trim","Error","this","floatSize","fillerCount","i","push","type","type_f32","add","byteSize","reduce","acc","cur","size","code","str","forEach","slice","object","obj","toFloat32Array","vals","Array","arr","Float32Array","length","offset","val","value","undefined","set","fromFloat32Array","createBuffer","isArray","newBuffer","Buffer","struct","error","message","buffers","nextData","nextBuffer","count","type_vec2","x","y","type_vec3","z","type_vec4","w","type_color","r","g","b","a","random","Math","createMouseBuffer","canvas","mouseStruct","mouseBuffer","mouseEvent","e","rect","getBoundingClientRect","mouseIsDown","buttons","update","width","clientX","left","height","clientY","top","document","addEventListener","createTimeBuffer","timeBuffer","setInterval","performance","now","RenderPass","texture","device","module","createShaderModule","pipeline","createRenderPipeline","layout","vertex","entryPoint","fragment","targets","format","canvasPresentationFormat","sampler","createSampler","magFilter","minFilter","bindGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","renderPassDescriptor","colorAttachments","clearValue","loadOp","storeOp","run","encoder","view","ctx","getCurrentTexture","createView","pass","beginRenderPass","setPipeline","setBindGroup","draw","end","ComputePass","bindings","dispatchSize","regex","renderTxtr","function","feedbackTxtr","auto","match","some","newBinding","multipleBuffer","find","multipleBufferIndex","findIndex","map","buffer","newBindings","bindingsCode","getBindingCode","createComputePipeline","compute","bind","beginComputePass","dispatchWorkgroups","runPasses","passes","repeats","commandEncoder","createCommandEncoder","p","queue","submit","finish","renderParams","bgColor","async","createRenderPass","options","createTextures","createClearPass","renderPass","basicRenderCode","Texture","write","exports","matchPass","clearPass","createMatchPass","read","initCanvas","navigator","gpu","adapter","requestAdapter","requestDevice","event","console","querySelector","createElement","container","containerId","getElementById","appendChild","clientWidth","clientHeight","style","display","body","window","innerWidth","innerHeight","getContext","getPreferredCanvasFormat","configure","alphaMode","key","href","toDataURL","download","Date","toISOString","replace","click","domReady","Promise","resolve","readyState","byteLength","label","usage","GPUBufferUsage","STORAGE","COPY_DST","COPY_SRC","mappedAtCreation","getMappedRange","unmap","writeBuffer","index","bufferType","getData","readBuffer","MAP_READ","copyBufferToBuffer","commands","mapAsync","GPUMapMode","READ","copyArrayBuffer","newdata","createTexture","GPUTextureUsage","STORAGE_BINDING","TEXTURE_BINDING","TextureBindingHelper","readOrWrite","bindingIndex","noiseBuffer","wgslNoise","wgslNoise2","cameraCode","WGSLParser","position","functions","peek","advance","skipWhitespace","test","skipComment","skipWhitespaceAndComments","skipped","before","readIdentifier","result","matchKeyword","keyword","start","findMatchingBrace","braceCount","parseFunction","parenCount","angleCount","bodyEnd","parse","fnCode","lineStart","line","join","extractFunctionsAndBody","warn","lines","split","filter","inFunction","currentFunction","startsWith","WGSLBuilder","structs","fn","params","returnType","group","main","strings","values","String","raw","parsedFunctions","wgsl","toFixed","setWidth","floor","initialPosition","initialLookAt","moveSpeed","sensitivity","customCameraCode","globalThis","target","cameraDistance","rotationSpeed","fieldOfView","nearPlane","farPlane","cameraY","mouse","time","feedback","inMin","inMax","outMin","outMax","color","v","max","min","ms","setTimeout"],"mappings":"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"}